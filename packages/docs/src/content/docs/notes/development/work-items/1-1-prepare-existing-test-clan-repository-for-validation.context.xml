<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1</storyId>
    <title>Prepare existing test-clan repository for validation</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-03</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/notes/development/work-items/1-1-prepare-existing-test-clan-repository-for-validation.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>system administrator</asA>
    <iWant>to review and prepare the existing test-clan repository for nix dendritic flake-parts + clan + terraform/terranix infrastructure validation</iWant>
    <soThat>I can validate both the architectural patterns and infrastructure provisioning before production deployment</soThat>
    <tasks>
- [ ] Review existing test-clan repository state (AC: #1)
  - [ ] Navigate to ~/projects/nix-workspace/test-clan/
  - [ ] Check git status and current branch
  - [ ] Review existing flake.nix structure
  - [ ] Identify existing modules/ organization
  - [ ] Document current state for baseline

- [ ] Create/confirm working branch for validation work (AC: #1)
  - [ ] Create branch: `git checkout -b phase-0-validation` or confirm on main
  - [ ] Ensure clean working state before modifications

- [ ] Update flake inputs for dendritic + clan + infrastructure integration (AC: #2)
  - [ ] Add clan-core input: `git+https://git.clan.lol/clan/clan-core` following nixpkgs/flake-parts
  - [ ] Add import-tree input: `github:vic/import-tree`
  - [ ] Add terranix input: `github:terranix/terranix` following flake-parts/nixpkgs
  - [ ] Add disko input: `github:nix-community/disko` following nixpkgs
  - [ ] Add srvos input: `github:nix-community/srvos` following nixpkgs
  - [ ] Configure input follows for clan-core: nixpkgs, flake-parts, sops-nix, home-manager, nix-darwin
  - [ ] Configure input follows for terranix: flake-parts, nixpkgs
  - [ ] Verify flake.lock updates after input changes

- [ ] Configure flake-parts.lib.mkFlake structure (AC: #2)
  - [ ] Update flake.nix outputs to use `flake-parts.lib.mkFlake { inherit inputs; }`
  - [ ] Add import-tree auto-discovery: `(inputs.import-tree ./modules)`
  - [ ] Verify flake structure follows dendritic pattern

- [ ] Import clan-core and terranix flakeModules (AC: #3)
  - [ ] Add `inputs.clan-core.flakeModules.default` to imports list
  - [ ] Add `inputs.terranix.flakeModule` to imports list (following clan-infra pattern)
  - [ ] Verify both flakeModules load without conflicts
  - [ ] Reference clan-infra pattern: docs/notes/implementation/clan-infra-terranix-pattern.md

- [ ] Create/verify modules/ directory structure for infrastructure (AC: #4)
  - [ ] Create modules/base/ for foundation modules (nix settings)
  - [ ] Create modules/hosts/ for machine-specific configurations
  - [ ] Create modules/flake-parts/ for flake-level configuration
  - [ ] Create modules/terranix/ for terraform/terranix modules (following clan-infra pattern)
  - [ ] Verify directory structure supports infrastructure deployment
  - [ ] Note: Dendritic pattern optional at this stage (Story 1.2 can be skipped)

- [ ] Test flake evaluation (AC: #5)
  - [ ] Run: `nix flake check`
  - [ ] Fix any evaluation errors discovered
  - [ ] Run: `nix flake show` to verify outputs structure
  - [ ] Verify no warnings or critical issues

- [ ] Update README.md with Phase 0 validation + infrastructure documentation (AC: #6)
  - [ ] Document purpose: Phase 0 architectural validation + infrastructure deployment environment
  - [ ] Document scope: Testing clan + infrastructure using clan-infra's proven terranix pattern, dendritic optimization secondary
  - [ ] Document strategy: Infrastructure-first (follow clan-infra patterns), dendritic optional/later
  - [ ] Document structure: Module organization, flake inputs, terraform/terranix setup, intended outcomes
  - [ ] Note disposable nature: Experimental repository for validation, can destroy infrastructure via terraform destroy
  - [ ] Reference integration-plan.md and clan-infra-terranix-pattern.md for patterns

- [ ] Verify clean git state (AC: #7)
  - [ ] Stage changes: `git add .`
  - [ ] Commit with atomic message: "chore(phase-0): prepare test-clan for clan + infrastructure validation"
  - [ ] Verify working tree clean: `git status`
  - [ ] Ready for next story (Story 1.2 dendritic pattern OPTIONAL, or skip to Story 1.4 terraform setup)
</tasks>
  </story>

  <acceptanceCriteria>
1. Existing test-clan repository at ~/projects/nix-workspace/test-clan/ reviewed and working branch created/confirmed
2. flake.nix updated to use flake-parts.lib.mkFlake with required inputs: nixpkgs, flake-parts, clan-core, import-tree, terranix, disko, srvos
3. Clan-core flakeModules.default and terranix.flakeModule imported
4. modules/ directory structure verified/created: modules/base/, modules/hosts/, modules/flake-parts/, modules/terranix/
5. Flake evaluates without errors: `nix flake check`
6. README.md updated to document Phase 0 validation + infrastructure deployment purpose and scope
7. Git working state clean and ready for iterative development (Story 1.2 or Story 1.4 depending on dendritic decision)
</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/notes/development/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR-1.1-1.6: Architectural Integration (Phase 0)</section>
        <snippet>FR-1.1: test-clan repository shall integrate clan-core flakeModules with dendritic flake-parts pattern (or hybrid approach if conflicts discovered). FR-1.5: Infrastructure deployment shall provision multi-cloud VMs with Hetzner Cloud CX53 VPS (cinnabar) via terranix using clan-infra's proven pattern. FR-1.6: Multi-machine coordination shall be validated with clan inventory managing 2 machines with heterogeneous cloud providers.</snippet>
      </doc>
      <doc>
        <path>docs/notes/development/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Epic 1: Architectural Validation + Infrastructure Deployment</section>
        <snippet>Story 1.1: Setup test-clan repository with both clan-core and terranix/terraform infrastructure, so that I can deploy real VMs (Hetzner + GCP) using proven patterns from clan-infra. Acceptance criteria include terranix flake module imported, modules/terranix/base.nix created with provider configuration, and terraform inputs available.</snippet>
      </doc>
      <doc>
        <path>docs/notes/implementation/clan-infra-terranix-pattern.md</path>
        <title>Clan-infra terranix pattern extraction</title>
        <section>Architecture overview</section>
        <snippet>Key components: 1) Terranix flake module imported from terranix input provides perSystem.terranix interface, 2) Terranix modules exported as flake.modules.terranix.*, 3) Machine-specific terraform configs, 4) State encryption via OpenTofu passphrase from clan secrets, 5) Clan secrets integration for provider credentials via `clan secrets get`</snippet>
      </doc>
      <doc>
        <path>docs/notes/implementation/clan-infra-terranix-pattern.md</path>
        <title>Clan-infra terranix pattern extraction</title>
        <section>Step 1: flake.nix changes</section>
        <snippet>Import terranix.flakeModule in machines/flake-module.nix: `imports = [ inputs.terranix.flakeModule ];` provides perSystem.terranix configuration interface. Pattern from clan-infra shows exact structure needed.</snippet>
      </doc>
      <doc>
        <path>docs/notes/implementation/clan-infra-terranix-pattern.md</path>
        <title>Clan-infra terranix pattern extraction</title>
        <section>Step 3: Create terranix modules directory</section>
        <snippet>modules/terranix/base.nix sets up terraform providers and fetches credentials from clan secrets using data.external.* pattern. Provider configuration references secrets via config.data.external.* "result.secret"</snippet>
      </doc>
      <doc>
        <path>docs/notes/clan/integration-plan.md</path>
        <title>Clan Integration Plan</title>
        <section>Phase 0 validation rationale</section>
        <snippet>Critical discovery: No production examples exist combining dendritic + clan patterns. Risk without Phase 0: Deploying untested architectural combination directly to production creates compound debugging complexity across 8 simultaneous layers. Solution: Phase 0 validation + deployment in test-clan validates dendritic + clan integration AND deploys real infrastructure (Hetzner Cloud VPS + GCP) to test complete stack before production.</snippet>
      </doc>
      <doc>
        <path>docs/notes/clan/integration-plan.md</path>
        <title>Clan Integration Plan</title>
        <section>Directory structure (target state)</section>
        <snippet>modules/ structure after course-correction: base/ (Foundation modules), nixos/ (NixOS-specific), darwin/ (Darwin-specific), shell/, dev/, hosts/ (Machine-specific includes cinnabar/), flake-parts/ (clan.nix, nixpkgs.nix, darwin-machines.nix, nixos-machines.nix, terranix.nix), terranix/ (base.nix for providers, ssh-keys.nix), users/</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>~/projects/nix-workspace/test-clan/flake.nix</path>
        <kind>flake configuration</kind>
        <symbol>outputs</symbol>
        <lines>1-40</lines>
        <reason>Existing test-clan flake structure using vanilla clan pattern - needs to be updated to flake-parts.lib.mkFlake with import-tree AND terranix.flakeModule for infrastructure deployment</reason>
      </artifact>
      <artifact>
        <path>~/projects/nix-workspace/test-clan/clan.nix</path>
        <kind>clan configuration</kind>
        <symbol>meta, inventory</symbol>
        <lines>1-59</lines>
        <reason>Existing clan inventory configuration - will be moved to modules/flake-parts/clan.nix following dendritic pattern</reason>
      </artifact>
      <artifact>
        <path>~/projects/nix-workspace/clan-infra/flake.nix</path>
        <kind>clan + flake-parts + terranix example</kind>
        <symbol>outputs</symbol>
        <lines>59-80</lines>
        <reason>Production clan-infra pattern: flake-parts.lib.mkFlake with clan-core.flakeModules.default AND terranix.flakeModule - PROVEN pattern to follow for test-clan infrastructure setup</reason>
      </artifact>
      <artifact>
        <path>~/projects/nix-workspace/clan-infra/machines/flake-module.nix</path>
        <kind>terranix configuration example</kind>
        <symbol>perSystem.terranix</symbol>
        <lines>120-180</lines>
        <reason>Production terranix configuration from clan-infra: shows perSystem.terranix.terranixConfigurations with terraform wrapper, state encryption, and clan secrets integration - critical reference for Story 1.1</reason>
      </artifact>
      <artifact>
        <path>~/projects/nix-workspace/clan-infra/modules/flake-module.nix</path>
        <kind>terranix modules export</kind>
        <symbol>flake.modules.terranix</symbol>
        <lines>1-20</lines>
        <reason>Shows how to export terranix modules to flake.modules.terranix.* namespace for reuse in terranixConfigurations - pattern needed for modules/flake-module.nix creation</reason>
      </artifact>
      <artifact>
        <path>~/projects/nix-workspace/clan-infra/modules/terranix/base.nix</path>
        <kind>terranix base module</kind>
        <symbol>provider configuration, data.external</symbol>
        <lines>1-50</lines>
        <reason>Production base terranix module: variable.passphrase for state encryption, terraform.required_providers declarations, data.external pattern for fetching clan secrets at terraform runtime - exact pattern to replicate in test-clan</reason>
      </artifact>
      <artifact>
        <path>~/projects/nix-workspace/drupol-dendritic-infra/flake.nix</path>
        <kind>dendritic flake example</kind>
        <symbol>outputs</symbol>
        <lines>58</lines>
        <reason>Canonical dendritic flake structure: `inputs.flake-parts.lib.mkFlake { inherit inputs; } (inputs.import-tree ./modules)` - target pattern for test-clan if dendritic optimization pursued (Story 1.2), but OPTIONAL for Story 1.1</reason>
      </artifact>
    </code>
    <dependencies>
      <nix>
        <input name="nixpkgs">nixos-unstable or nixpkgs-unstable (latest stable)</input>
        <input name="flake-parts">hercules-ci/flake-parts (module system foundation, required by both clan and terranix)</input>
        <input name="clan-core">git+https://git.clan.lol/clan/clan-core (multi-machine coordination, inventory system, vars management)</input>
        <input name="import-tree">github:vic/import-tree (automatic module discovery for dendritic pattern)</input>
        <input name="terranix">github:terranix/terranix (terraform configuration via Nix, provides flakeModule for perSystem integration)</input>
        <input name="disko">github:nix-community/disko (declarative disk partitioning, LUKS encryption support)</input>
        <input name="srvos">github:nix-community/srvos (server hardening modules, security baseline)</input>
      </nix>
    </dependencies>
  </artifacts>

  <constraints>
**Infrastructure-first strategy (post-course-correction):**
- Infrastructure deployment using clan-infra's proven terranix pattern is PRIMARY objective
- Dendritic pattern optimization is SECONDARY and can be skipped (Story 1.2 optional)
- Story 1.1 creates STRUCTURE for infrastructure deployment, not full pattern implementation
- Following Epic 1 restructuring: 12 stories (was 6) with infrastructure deployment as core focus

**Architectural flexibility:**
- Dendritic pattern can be added in Story 1.2 if time permits and does not conflict with infrastructure
- If dendritic conflicts with terranix/clan integration: SKIP Story 1.2 and proceed to Story 1.4 (terraform setup)
- Hybrid approaches acceptable: partial dendritic adoption, minimal specialArgs usage, pragmatic compromises
- clan-infra uses manual imports (not import-tree) which is a proven alternative

**Validation constraints:**
- This is experimental - failure is acceptable and informative
- Zero-regression mandate does NOT apply to test-clan (experimental environment, disposable infrastructure)
- Solo operator workflow - no team coordination required
- Local validation only - no CI for Phase 0
- Expected execution time: 2-4 hours (increased from 1-2 due to infrastructure setup scope)

**Technical constraints:**
- Must follow clan-infra terranix patterns exactly (proven in production)
- Terraform state encryption via OpenTofu with passphrase from clan secrets
- Provider credentials fetched via `clan secrets get` at terraform runtime
- modules/terranix/ directory structure required for terraform modules
- terranix.flakeModule import in machines/flake-module.nix (not in flake.nix directly)

**Story scope:**
- First story in epic - no predecessor context to inherit
- Creates skeleton only, subsequent stories (1.2-1.12) implement functionality
- Acceptance criteria focus on structure validation, not deployment (deployment in Stories 1.5, 1.8)
</constraints>

  <interfaces>
    <interface>
      <name>flake-parts.lib.mkFlake</name>
      <kind>Nix flake API</kind>
      <signature>mkFlake { inherit inputs; } (attrset or function returning attrset)</signature>
      <path>N/A (flake-parts library function)</path>
    </interface>
    <interface>
      <name>import-tree</name>
      <kind>Nix flake function</kind>
      <signature>import-tree ./path-to-modules (recursively imports all .nix files as flake-parts modules)</signature>
      <path>N/A (import-tree library function)</path>
    </interface>
    <interface>
      <name>clan-core.flakeModules.default</name>
      <kind>flake-parts module</kind>
      <signature>Provides clan.* namespace options (meta.name, inventory.machines, inventory.instances, specialArgs, secrets)</signature>
      <path>clan-core flake output</path>
    </interface>
    <interface>
      <name>terranix.flakeModule</name>
      <kind>flake-parts module</kind>
      <signature>Provides perSystem.terranix configuration interface for terranixConfigurations with terraformWrapper options</signature>
      <path>terranix flake output (import in machines/flake-module.nix)</path>
    </interface>
    <interface>
      <name>perSystem.terranix.terranixConfigurations</name>
      <kind>Terranix configuration API</kind>
      <signature>attrset of { workdir, modules, terraformWrapper = { package, extraRuntimeInputs, prefixText } }</signature>
      <path>Defined in machines/flake-module.nix after importing terranix.flakeModule</path>
    </interface>
    <interface>
      <name>flake.modules.terranix</name>
      <kind>Terranix modules namespace</kind>
      <signature>attrset of module paths (base.nix, dns.nix, with-dns.nix, etc.) exported for reuse in terranixConfigurations</signature>
      <path>Defined in modules/flake-module.nix</path>
    </interface>
    <interface>
      <name>data.external.*</name>
      <kind>Terraform data source (via terranix)</kind>
      <signature>{ program = [ path-to-script ]; } - Executes shell script returning JSON for use in terraform configuration</signature>
      <path>Used in modules/terranix/base.nix to fetch clan secrets at terraform runtime</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
**Local validation commands for Phase 0 (infrastructure-first):**
- `nix flake check` - Validates flake syntax and evaluation (terranix modules must evaluate)
- `nix flake show` - Shows flake outputs structure (should include terranix packages)
- `nix eval .#terranix --apply builtins.attrNames` - Verifies terranix configurations available
- `nix eval .#clan.inventory --json | jq .` - Validates clan inventory structure
- `nix build .#terranix.terraform` - Builds terraform configuration (validates terranix modules compile)
- Manual review of generated terraform.tf.json for correctness

**Terraform validation (after Story 1.4 terraform configuration):**
- `nix run .#terranix.terraform -- init` - Initializes terraform with providers
- `nix run .#terranix.terraform -- validate` - Validates terraform syntax
- `nix run .#terranix.terraform -- plan` - Dry-run terraform deployment

**No automated testing infrastructure for Phase 0** - manual validation sufficient for experimental repository. CI expansion deferred to post-migration.
    </standards>
    <locations>
N/A (Story 1.1 is setup/skeleton only, no test files created)
    </locations>
    <ideas>
- Flake evaluation test: verify flake.nix evaluates without errors after adding terranix + infrastructure inputs
- import-tree discovery test: verify import-tree finds all modules in modules/ directory (including terranix/)
- Clan inventory validation test: verify clan.inventory.machines and clan.inventory.instances evaluate correctly
- Terranix module namespace test: verify flake.modules.terranix.* namespace is created
- Terranix configuration test: verify perSystem.terranix.terranixConfigurations are defined
- Terraform generation test: verify `nix build .#terranix.terraform` produces terraform.tf.json
- State encryption test: verify TF_ENCRYPTION environment variable is exported in terraformWrapper.prefixText
- Clan secrets integration test: verify data.external pattern for fetching secrets compiles in base.nix
    </ideas>
  </tests>
</story-context>
