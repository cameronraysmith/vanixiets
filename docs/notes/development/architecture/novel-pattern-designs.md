# Novel Pattern Designs

**Last Updated**: 2025-11-21
**Status**: Updated with Epic 1 validation evidence (Stories 1.8A, 1.10A-1.10E, 1.12)

This document describes novel architectural patterns discovered, designed, and validated during Epic 1 test-clan implementation.

## Epic 1 Validated Patterns

### Pattern 1: Two-Tier Secrets Architecture (Clan Vars + sops-nix)

**Status**: ✅ VALIDATED (Epic 1 Stories 1.10A, 1.10C - multi-user encryption proven)

**Problem**: System-level secrets (SSH host keys, zerotier identities) and user-level secrets (GitHub tokens, API keys) have different scopes, lifecycles, and encryption requirements. Single-tier approach creates security and organizational issues.

**Solution**: Separate system secrets (Tier 1: clan vars) from user secrets (Tier 2: sops-nix) with shared age keypair pattern.

**Tier 1: Clan Vars (System-Level)**
- Purpose: Generated secrets for machine infrastructure
- Examples: SSH host keys, zerotier identities, ZFS/LUKS passphrases
- Encryption: Machine age keys (`/var/lib/sops-nix/key.txt`)
- Deployment: `/run/secrets/vars/` via clan-core
- Management: `clan vars generate`, `clan vars fix`
- Generator-driven: Auto-generated by clan generators

```nix
# Clan vars generator example
clan.core.vars.generators.openssh = {
  files."ssh.id_ed25519".neededFor = [ "sshd.service" ];
  files."ssh.id_ed25519.pub".secret = false;
  script = ''
    ssh-keygen -t ed25519 -N "" -f "$out/ssh.id_ed25519"
  '';
};
```

**Tier 2: sops-nix (User-Level)**
- Purpose: User identity secrets for home-manager
- Examples: GitHub tokens, SSH signing keys, Bitwarden emails
- Encryption: User age keys derived from SSH keys
- Deployment: `~/.config/sops/secrets/` via home-manager
- Management: `sops` CLI with `.sops.yaml` rules
- Manually created: Values provided by users

```yaml
# .sops.yaml multi-user encryption rules
keys:
  - &admin age1vy7wsnf8eg5229evq3ywup285jzk9cntsx5hhddjtwsjh0kf4c6s9fmalv
  - &crs58-user age1vn8fpkmkzkjttcuc3prq3jrp7t5fsrdqey74ydu5p88keqmcupvs8jtmv8
  - &raquel-user age12w0rmmskrds6m334w7qrcmpms5lpe3llah6wf8ry5jtatvuxku2sarl8ut

creation_rules:
  - path_regex: secrets/home-manager/users/crs58/.*\.yaml$
    key_groups:
      - age: [*admin, *crs58-user]
  - path_regex: secrets/home-manager/users/raquel/.*\.yaml$
    key_groups:
      - age: [*admin, *raquel-user]
```

**Shared Age Keypair Pattern**:
- Same SSH key → same age key (deterministic via `ssh-to-age`)
- User age key used for BOTH tiers (clan user key + sops-nix decryption key)
- Bitwarden as source of truth for SSH keys
- Age keys are ephemeral derivations

**Epic 1 Validation Evidence**:
- ✅ Multi-user encryption: crs58 (8 secrets), raquel (5 secrets) - Story 1.10C
- ✅ Cross-platform: darwin (blackphos) + nixos (cinnabar, electrum) - Story 1.12
- ✅ Production stability: 3+ weeks operation, zero secret-related issues
- ✅ SSH-to-age derivation proven reliable and deterministic
- ✅ Reference: `~/projects/nix-workspace/test-clan/docs/architecture/secrets-and-vars-architecture.md` (279 lines)

**Benefits**:
- Clear separation: System secrets vs user secrets
- Independent lifecycles: Machine redeployment doesn't affect user secrets
- Multi-user support: Each user encrypts own secrets with own age key
- Cross-platform: Works identically on darwin + nixos
- Shared key pattern: Same age keypair for both tiers (simple, secure)

**Architectural Insights**:
- Machine age keys ≠ SSH host keys (independent keypairs)
- `clan vars fix` re-encrypts without regenerating values (SOPS updatekeys)
- Multi-user encryption: Any authorized age key can decrypt secret

### Pattern 2: Five-Layer Overlay Architecture

**Status**: ✅ VALIDATED (Epic 1 Stories 1.10D, 1.10DA, 1.10DB - all layers empirically proven)

**Problem**: Package customization requires managing: multi-channel nixpkgs (stable/unstable), platform hotfixes, custom packages, version overrides, and flake input overlays. Single overlay approach creates conflicts and ordering issues.

**Solution**: Five distinct overlay layers with explicit composition order.

**Layer 1: Inputs (Multi-Channel)**
```nix
# modules/nixpkgs/overlays/channels.nix
{ inputs, ... }: {
  flake.nixpkgsOverlays = [
    (final: prev: {
      stable = import inputs.nixpkgs-linux-stable {
        system = final.system;
        config.allowUnfree = true;
      };
      unstable = import inputs.nixpkgs {
        system = final.system;
        config.allowUnfree = true;
      };
    })
  ];
}
```

**Layer 2: Hotfixes (Platform Fallbacks)**
```nix
# modules/nixpkgs/overlays/hotfixes.nix
{ ... }: {
  flake.nixpkgsOverlays = [
    (final: prev: {
      # Use stable micromamba when unstable broken
      micromamba = final.stable.micromamba;  # 1.5.8 from stable
    })
  ];
}
```

**Layer 3: pkgs-by-name (Custom Packages)**
```nix
# modules/nixpkgs/pkgs-by-name/ccstatusline/package.nix
{ stdenv, fetchFromGitHub, ... }:
stdenv.mkDerivation {
  pname = "ccstatusline";
  version = "0.1.0";
  src = fetchFromGitHub {
    owner = "cameronraysmith";
    repo = "ccstatusline";
    # ...
  };
}
```

**Layer 4: Overrides (Package Modifications)**
```nix
# modules/nixpkgs/overlays/overrides.nix
{ ... }: {
  flake.nixpkgsOverlays = [
    (final: prev: {
      myPackage = prev.myPackage.overrideAttrs (old: {
        buildInputs = old.buildInputs ++ [ final.someLib ];
      });
    })
  ];
}
```

**Layer 5: Flake Inputs (Ecosystem Overlays)**
```nix
# modules/nixpkgs/overlays/flake-inputs.nix
{ inputs, ... }: {
  flake.nixpkgsOverlays = [
    (final: prev: {
      lazyvim-nix = inputs.lazyvim-nix.packages.${final.system}.default;
      claude-code = inputs.nix-ai-tools.packages.${final.system}.claude-code;
      catppuccin = inputs.catppuccin.packages.${final.system};
    })
  ];
}
```

**Overlay Composition** (all layers merged):
```nix
# modules/nixpkgs/compose.nix
{ config, lib, ... }: {
  flake.overlays.default = final: prev:
    let
      # Compose all nixpkgsOverlays in order
      internalOverlays = lib.composeManyExtensions config.flake.nixpkgsOverlays;
    in
    internalOverlays final prev;
}
```

**Epic 1 Validation Evidence**:
- ✅ All 5 layers empirically validated (epic-1-retro:347-362)
- ✅ Layer 1: stable (25.05) vs unstable channels working
- ✅ Layer 2: micromamba hotfix proven (stable 1.5.8 when unstable broken)
- ✅ Layer 3: ccstatusline custom package via pkgs-by-name-for-flake-parts
- ✅ Layer 4: Package override infrastructure validated
- ✅ Layer 5: lazyvim-nix, catppuccin-nix, nix-ai-tools, nuenv integrated
- ✅ Zero package conflicts across layers, deterministic composition

**Benefits**:
- Clear separation of concerns (each layer has specific purpose)
- Predictable composition order (Layer 1 → 2 → 3 → 4 → 5)
- Easy to add packages (create file in appropriate layer directory)
- Auto-discovery via dendritic pattern (import-tree)
- Opportunistic improvements enabled (replace custom with ecosystem flake inputs)

**Opportunistic Improvements Pattern**:
- LazyVim-module → lazyvim-nix (Layer 5, Epic 1 Story 1.10E)
- Custom catppuccin → catppuccin-nix (Layer 5, Epic 1 Story 1.10E)
- Custom claude-code → nix-ai-tools (Layer 5, Epic 1 Story 1.10E)

### Pattern 3: Home-Manager Pattern A (Dendritic Aggregates with Explicit Braces)

**Status**: ✅ VALIDATED (Epic 1 Stories 1.8A, 1.10BA, 1.10C, 1.10E, 1.12 - 270 packages preserved)

**Problem**: Home-manager configurations need cross-platform portability (darwin + nixos), flake context access (inputs, overlays), and option definition separation for reusability. Inline configs block portability, Pattern B (direct merging) lacks flake context.

**Solution**: Pattern A uses explicit braces (two-layer module system) with separate option definition modules.

**Two-Layer Module System**:
```nix
# Outer layer: flake-parts module (dendritic namespace export)
{ inputs, config, ... }: {
  flake.modules.homeManager."users/crs58" =
    # Inner layer: home-manager module (explicit braces for flake context)
    { config, pkgs, lib, ... }: {
      imports = [
        # Import option definition modules
        ../../../home/modules/_agents-md.nix
        ../../../home/modules/_zsh.nix
      ];

      # Access flake context (available due to explicit braces)
      home.packages = [
        inputs.lazyvim-nix.packages.${pkgs.system}.default
        config.flake.overlays.default.claude-code
      ];

      # Configure options defined in _*.nix modules
      programs.zsh.enable = true;
      programs.agents-md.enable = true;
    };
}
```

**Option Definition Modules** (separate `_*.nix` files):
```nix
# home/modules/_agents-md.nix (portable option definition)
{ lib, ... }:
{
  options.programs.agents-md = {
    enable = lib.mkEnableOption "agents.md configuration";
    defaultDir = lib.mkOption {
      type = lib.types.str;
      default = "~/.config/agents-md";
    };
  };

  config = lib.mkIf config.programs.agents-md.enable {
    # Implementation when enabled
  };
}
```

**Clan Inventory Integration** (relative imports pattern):
```nix
# modules/clan/inventory/services/users/crs58.nix
{ config, ... }:
{
  clan.inventory.services.user-crs58 = {
    roles.default.machines = [ "blackphos" "cinnabar" ];
    roles.default.config = { config, ... }: {
      users.users.crs58 = {
        isNormalUser = true;
        extraGroups = [ "wheel" ];
      };

      home-manager.users.crs58 = {
        imports = [
          # RELATIVE import (clan inventory cannot reference flake namespaces)
          ../../../home/users/crs58/default.nix
        ];
      };
    };
  };
}
```

**Epic 1 Validation Evidence**:
- ✅ Cross-platform: darwin (blackphos) + nixos (cinnabar, electrum) - Story 1.12
- ✅ Multi-user: crs58, raquel, cameron, testuser (4 users functional) - Story 1.8A
- ✅ Production deployment: blackphos 270 packages preserved - Story 1.12
- ✅ Flake context access: inputs, overlays working - Story 1.10E
- ✅ Secrets integration: sops-nix user-level secrets - Story 1.10C
- ✅ Module count: 17 home-manager modules in aggregates structure

**Benefits**:
- Cross-platform portability (same code works darwin + nixos)
- Flake context access (inputs, overlays available)
- Option definition separation (reusable `_*.nix` modules)
- Clan inventory compatible (via relative imports pattern)
- Type-safe (explicit option declarations in `_*.nix` files)

**Architectural Insights**:
- **Explicit braces required**: Enables flake context access in inner module
- **Separate option definition**: `_*.nix` files define options, `*.nix` configure values
- **Clan limitation**: Inventory cannot reference `config.flake.modules.*` - use relative imports
- **Pattern B rejected**: Direct merging loses flake context (Story 1.10B → 1.10BA pivot)
- **Story 1.11 deferred**: Pattern A proven sufficient, type-safe homeHosts unnecessary

### Pattern 4: Auto-Merge Base Modules via Import-Tree

**Problem**: Dendritic pattern requires explicit module exports, but system-wide configurations (nix settings, admin users, initrd networking) should be automatically available to all machines without manual imports.

**Solution**: Import-tree automatically merges all files in `modules/system/` into `flake.modules.nixos.base`:

```nix
# modules/system/nix-settings.nix
{ flake.modules.nixos.base.nix.settings = { experimental-features = ["nix-command" "flakes"]; }; }

# modules/system/admins.nix
{ flake.modules.nixos.base.users.users.crs58 = { extraGroups = ["wheel"]; }; }

# Result: Single merged base module
flake.modules.nixos.base = {
  nix.settings = { ... };
  users.users.crs58 = { ... };
  boot.initrd.network = { ... };
};
```

**Benefits**:
- Zero manual imports for base functionality
- Single reference in machine configs: `imports = [ config.flake.modules.nixos.base ];`
- Add new system-wide config: create file in `system/` → auto-merged
- Test-clan validated (Stories 1.1-1.7, 17 test cases passing)

**Pattern 2: Portable Home-Manager Modules with Dendritic Integration**

**Problem**: User home-manager configurations need to work across platforms (darwin + NixOS) and support three integration modes (darwin integrated, NixOS integrated, standalone) without duplication.

**Gap Identified (Story 1.8)**: blackphos implemented inline home configs, blocking cross-platform reuse. This is a feature regression from infra's proven modular pattern.

**Solution (Story 1.8A - COMPLETE)**: Extracted home configs into portable modules that export to dendritic namespace and support all three integration modes. Validated in test-clan with zero regression (270 packages preserved, 46 lines of duplication removed from blackphos).

**Module Structure:**
```nix
# modules/home/users/{username}/default.nix
{
  flake.modules.homeManager."users/{username}" = { config, pkgs, lib, ... }: {
    home.stateVersion = "23.11";
    programs.zsh.enable = true;
    programs.starship.enable = true;
    programs.git.enable = true;
    home.packages = with pkgs; [ git gh ... ];
  };
}
```

**Three Integration Modes:**

**Mode 1: Darwin Integrated** (blackphos example)
```nix
# In darwin machine module
{
  imports = [
    inputs.home-manager.darwinModules.home-manager
  ];

  home-manager.useGlobalPkgs = true;
  home-manager.useUserPackages = true;

  home-manager.users.crs58.imports = [
    config.flake.modules.homeManager."users/crs58"
  ];
}
```

**Mode 2: NixOS Integrated** (cinnabar Story 1.9)
```nix
# In NixOS machine module
{
  imports = [
    inputs.home-manager.nixosModules.home-manager
  ];

  home-manager.useGlobalPkgs = true;
  home-manager.useUserPackages = true;

  home-manager.users.crs58.imports = [
    config.flake.modules.homeManager."users/crs58"
  ];
}
```

**Mode 3: Standalone** (nh home CLI workflow)
```nix
# In modules/home/configurations.nix
{
  flake.homeConfigurations.crs58 = inputs.home-manager.lib.homeManagerConfiguration {
    pkgs = import inputs.nixpkgs { system = "aarch64-darwin"; };
    modules = [
      config.flake.modules.homeManager."users/crs58"
    ];
  };
}

# Usage: nh home switch . -c crs58
```

**Benefits:**
- Single source of truth (DRY principle): User defined once, used on 6 machines
- Cross-platform portability: Same module works on darwin and NixOS
- Three deployment contexts: Integrated (system + home), standalone (home only)
- Dendritic auto-discovery: No manual imports in flake.nix
- Username-only naming: No @hostname for maximum portability
- Clan compatible: Users defined per machine, configs imported modularly

**Lesson from Story 1.8:**
Inline home configs are anti-pattern for multi-machine infrastructure. Always modularize user configs to enable cross-platform reuse.

**Implementation Status (Story 1.8A):**
- ✅ crs58 and raquel modules created in test-clan (`modules/home/users/{username}/default.nix`)
- ✅ Exported to dendritic namespace (`flake.modules.homeManager."users/{username}"`)
- ✅ Standalone homeConfigurations exposed (`flake.homeConfigurations.{crs58,raquel}`)
- ✅ blackphos refactored to import from namespace (zero regression validated)
- ✅ Standalone activation tested (`nh home switch . -c {username}`)
- ✅ Pattern ready for Story 1.9 (cinnabar NixOS needs crs58 module)

**Pattern 3: Darwin Multi-User with Per-User Vars Naming**

**Problem**: Clan vars generators are machine-scoped, not user-scoped. Multi-user darwin machines (blackphos: raquel + crs58) need separate secrets per user.

**Solution**: Use naming convention in generator names:

```nix
# Generate per-user secrets with naming convention
clan.core.vars.generators."ssh-key-crs58" = {
  files."id_ed25519".neededFor = "users";
  files."id_ed25519.pub".secret = false;
  script = ''ssh-keygen -t ed25519 -N "" -C "crs58@${config.networking.hostName}" -f "$out"/id_ed25519'';
};

clan.core.vars.generators."ssh-key-raquel" = {
  files."id_ed25519".neededFor = "users";
  files."id_ed25519.pub".secret = false;
  script = ''ssh-keygen -t ed25519 -N "" -C "raquel@${config.networking.hostName}" -f "$out"/id_ed25519'';
};

# Result storage
vars/per-machine/blackphos/ssh-key-crs58/id_ed25519
vars/per-machine/blackphos/ssh-key-raquel/id_ed25519
```

**Admin vs Non-Admin Differentiation**:
```nix
# modules/darwin/users.nix
users.users.crs58 = {
  uid = 550;
  extraGroups = [ "admin" ];  # Darwin equivalent of "wheel"
  home = "/Users/crs58";
};

users.users.raquel = {
  uid = 551;
  extraGroups = [ ];  # No admin group = no sudo
  home = "/Users/raquel";
};

# Security configuration
security.sudo.wheelNeedsPassword = false;  # Passwordless sudo for admins
```

**Home-Manager Per-User**:
```nix
home-manager.users.crs58.imports = with config.flake.modules.homeManager; [
  core.zsh
  users.crs58.dev-tools  # Admin user gets full dev environment
];

home-manager.users.raquel.imports = with config.flake.modules.homeManager; [
  core.zsh  # Non-admin gets minimal shell config only
];
```

**Benefits**:
- Standard NixOS user management (no clan-specific patterns)
- Per-user secrets via generator naming convention
- Clear admin/non-admin separation via `extraGroups`
- Home-manager configs scale independently
- Validated in production examples (clan-infra admins.nix, mic92 bernie machine)

**Pattern 3: Darwin Networking Options (Zerotier Workaround)**

**Problem**: Clan zerotier service is NixOS-only (systemd dependencies, no darwin support). Darwin hosts need mesh networking but clan service doesn't work.

**Solution**: Multiple validated options with trade-offs:

**Option A: Homebrew Zerotier** (maintains zerotier consistency):
```nix
# modules/darwin/homebrew.nix
homebrew.enable = true;
homebrew.casks = [ "zerotier-one" ];  # GUI app via homebrew

# Manual network join after installation
# Use clan-generated network-id: /run/secrets/zerotier-network-id
# Command: zerotier-cli join $(cat /run/secrets/zerotier-network-id)
```

**Option B: Custom Launchd Service** (nix-managed zerotier):
```nix
# modules/darwin/zerotier-custom.nix
launchd.daemons.zerotierone = {
  serviceConfig = {
    Program = "${pkgs.zerotierone}/bin/zerotier-one";
    ProgramArguments = [ "${pkgs.zerotierone}/bin/zerotier-one" ];
    KeepAlive = true;
    RunAtLoad = true;
  };
};

# Reference identity from clan vars
environment.etc."zerotier-one/identity.secret".source =
  config.clan.core.vars.generators.zerotier.files.zerotier-identity-secret.path;
```

**Hybrid Approach** (recommended for Story 1.8):
- Use clan vars generators for identity/network-id (platform-agnostic Python scripts)
- Manual zerotier setup on darwin (homebrew or custom launchd)
- Cinnabar controller auto-accepts peers using clan-generated zerotier-ip

**Benefits**:
- Maintains clan vars for identity management (reusable patterns)
- Defers darwin networking implementation to Story 1.8 (experimental validation)
- Multiple proven alternatives (tailscale, homebrew, custom launchd)
- No blocking unknowns for architecture documentation

**Pattern 4: Terranix Toggle-Based Deployment**

**Problem**: Multiple cloud VMs (cinnabar always-on, electrum togglable) need declarative deployment control without destroying terraform state.

**Solution**: Per-machine `enabled` flag in terranix configuration:

```nix
# modules/terranix/hetzner.nix
{ config, lib, ... }:
let
  machines = {
    hetzner-ccx23 = {
      enabled = false;  # Destroy this VM
      server_type = "ccx23";
      location = "nbg1";
    };
    hetzner-cx43 = {
      enabled = true;   # Deploy this VM
      server_type = "cx43";
      location = "fsn1";
    };
  };

  enabledMachines = lib.filterAttrs (_: m: m.enabled) machines;
in
{
  perSystem = { config, pkgs, ... }: {
    terranix.terraform.resource.hcloud_server = lib.mapAttrs (name: cfg: {
      name = name;
      server_type = cfg.server_type;
      location = cfg.location;
      # ...
    }) enabledMachines;
  };
}
```

**Terraform Operations**:
```bash
# Deploy enabled machines only
nix run .#terraform.terraform -- apply

# Toggle machine: set enabled = false → terraform apply → VM destroyed
# Toggle back: set enabled = true → terraform apply → VM recreated
```

**Benefits**:
- Declarative VM lifecycle management
- Toggle without manual terraform destroy commands
- Preserves terraform state for both machines
- Test-clan validated (hetzner-ccx23 toggled off, hetzner-cx43 deployed)

**Pattern 5: Test Harness with Multiple Categories**

**Problem**: Complex infrastructure requires different validation types (fast expression tests, slow VM integration tests, structural validation, performance benchmarks).

**Solution**: Multi-category test harness with selective execution:

```nix
# modules/checks/nix-unit.nix
flake.checks."${system}".test-nix-unit-all = pkgs.stdenv.mkDerivation {
  name = "test-nix-unit-all";
  buildCommand = ''
    export HOME=$TMPDIR
    ${nix-unit}/bin/nix-unit \
      --flake "${self}#checks.${system}.nix-unit-tests" \
      --eval-store "$HOME"
  '';
};

# modules/checks/integration.nix (runNixOSTest)
flake.checks."${system}".test-vm-boot-hetzner-ccx23 =
  self.nixosConfigurations.hetzner-ccx23.config.system.build.vmWithBootLoaderTest or null;
```

**Test Execution Matrix**:
| Category | Tool | Tests | Duration | Systems | Purpose |
|----------|------|-------|----------|---------|---------|
| nix-unit | nix-unit | 11 | ~1s | all (x86_64-linux, aarch64-linux, aarch64-darwin) | Fast expression evaluation |
| integration | runNixOSTest | 2 | ~2-5min | Linux only | VM boot validation |
| validation | runCommand | 4 | ~4s | all | Structural invariants |
| performance | runCommand | 0 | ~0s | all | Build time benchmarks (future) |

**Selective Execution**:
```bash
# Fast tests only (< 5s)
nix flake check --no-build

# Full validation (includes VM tests)
nix flake check

# Specific category
nix build .#checks.x86_64-linux.test-nix-unit-all
```

**Benefits**:
- Fast feedback loop (nix-unit tests ~1s)
- Comprehensive validation (17 test cases across 4 categories)
- Platform-aware (VM tests skip on darwin)
- Test-clan validated (all 17 tests passing)
