<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>4</storyId>
    <title>Create Hetzner VM terraform configuration and host modules</title>
    <status>drafted</status>
    <generatedAt>2025-11-04</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/notes/development/work-items/1-4-create-hetzner-terraform-config-and-host-modules.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a system administrator</asA>
    <iWant>to create terraform configuration for Hetzner Cloud VM provisioning</iWant>
    <soThat>I can deploy hetzner-vm using proven patterns from clan-infra</soThat>
    <tasks>
- [ ] Create Hetzner terranix configuration (AC: #1-4)
  - [ ] Create modules/terranix/hetzner.nix file
  - [ ] Configure hcloud provider with API token from clan secrets
  - [ ] Define SSH key resource for terraform deployment
  - [ ] Configure hcloud_server resource (CX22 or CX32 size)
  - [ ] Add null_resource provisioner calling `clan machines install hetzner-vm`
  - [ ] Follow clan-infra vultr.nix pattern as reference

- [ ] Enhance Hetzner host base configuration (AC: #5-6)
  - [ ] Enhance existing modules/hosts/hetzner-vm/default.nix (created in Story 1.3)
  - [ ] Verify hostname = "hetzner-vm" (set in Story 1.3)
  - [ ] Verify system.stateVersion = "25.05" (set in Story 1.3)
  - [ ] Verify nix-settings.nix import (base module imported in Story 1.3)
  - [ ] Import srvos hardening modules (NEW for Story 1.4)
  - [ ] Configure networking (DHCP, firewall basics - NEW for Story 1.4)
  - [ ] Verify nixpkgs.hostPlatform = "x86_64-linux" (set in Story 1.3)

- [ ] Create Hetzner disko configuration (AC: #7, #13)
  - [ ] Create modules/hosts/hetzner-vm/disko.nix
  - [ ] Configure EFI boot partition
  - [ ] Configure LUKS encrypted root partition
  - [ ] Set up filesystem layout (ext4 or btrfs)
  - [ ] Verify disko configuration follows clan-infra patterns
  - [ ] IMPORTANT: Validate boot device path (/dev/sda vs /dev/vda) - Hetzner may use either depending on virtualization (AC: #13)

- [ ] Store Hetzner API token in clan secrets (AC: #8)
  - [ ] Ensure clan secrets initialized (age keys)
  - [ ] Store token: `clan secrets set hetzner-api-token`
  - [ ] Verify token retrievable: `clan secrets get hetzner-api-token`

- [ ] Test terraform configuration generation (AC: #9-10)
  - [ ] Build terranix output: `nix build .#terranix.terraform`
  - [ ] Review generated terraform.tf.json for correctness
  - [ ] Verify hcloud provider configuration present
  - [ ] Verify server resource configuration present
  - [ ] Verify null_resource provisioner present

- [ ] Test host configuration build (AC: #11)
  - [ ] Build NixOS configuration: `nix build .#nixosConfigurations.hetzner-vm.config.system.build.toplevel`
  - [ ] Verify no build errors
  - [ ] Check output includes expected packages and services

- [ ] Test disko configuration evaluation (AC: #12)
  - [ ] Evaluate disko disks: `nix eval .#nixosConfigurations.hetzner-vm.config.disko.disks --apply toString`
  - [ ] Verify LUKS configuration present
  - [ ] Verify partition layout correct
</tasks>
  </story>

  <acceptanceCriteria>
1. modules/terranix/hetzner.nix created with Hetzner Cloud provider configuration
2. SSH key resource defined for terraform deployment key
3. Hetzner Cloud server resource configured (CX22 or CX32, 2-4 vCPU for testing)
4. null_resource configured for `clan machines install hetzner-vm` provisioning (referencing inventory machine)
5. modules/hosts/hetzner-vm/default.nix enhanced with srvos hardening and production-ready base configuration
6. srvos hardening modules imported in host configuration
7. modules/hosts/hetzner-vm/disko.nix created with LUKS encryption and standard partition layout
8. Hetzner API token stored as clan secret: `clan secrets set hetzner-api-token`
9. Terraform configuration generates: `nix build .#terranix.terraform`
10. Generated terraform.tf.json manually reviewed for correctness
11. Host configuration builds: `nix build .#nixosConfigurations.hetzner-vm.config.system.build.toplevel`
12. Disko partition commands generate: `nix eval .#nixosConfigurations.hetzner-vm.config.disko.disks --apply toString`
13. Boot device path validation: Verify /dev/sda or /dev/vda device naming during disko configuration
</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/notes/development/PRD.md" title="infra - Product Requirements Document" section="Phase 0 - Validation Environment + Infrastructure Deployment">
        PRD defines Epic 1 (Phase 0) objectives: validate dendritic + clan patterns in test-clan, deploy Hetzner + GCP VMs using clan-infra's proven terranix pattern before darwin migration. Infrastructure deployment uses terraform/terranix + clan integration with disko LUKS encryption and zerotier mesh networking.
      </doc>
      <doc path="docs/notes/development/epic-1-infrastructure-restructure-proposal.md" title="Epic 1 Infrastructure Deployment Restructure" section="Story 1.4: Create Hetzner VM terraform configuration and host modules">
        Story 1.4 creates terraform/terranix configuration for Hetzner Cloud provisioning using clan-infra's proven pattern. Must create modules/terranix/hetzner.nix with hcloud provider, enhance existing modules/hosts/hetzner-vm/default.nix with srvos hardening, and create modules/hosts/hetzner-vm/disko.nix with LUKS encryption. Hetzner API token stored in clan secrets.
      </doc>
      <doc path="docs/notes/implementation/clan-infra-terranix-pattern.md" title="Clan-infra terranix pattern extraction" section="Step-by-step implementation">
        Complete reference guide for terranix + clan integration. Key patterns: modules/terranix/base.nix fetches secrets via data.external calling clan secrets get, terranixConfigurations in machines/flake-module.nix with terraformWrapper.prefixText for TF_VAR_passphrase and TF_ENCRYPTION state encryption, null_resource provisioner calls clan machines install for deployment.
      </doc>
      <doc path="docs/notes/development/work-items/1-3-configure-clan-inventory-and-service-instances-for-test-vm.md" title="Story 1.3: Configure clan inventory" section="Learnings">
        Story 1.3 created inventory with hetzner-vm and gcp-vm machines at modules/hosts/*/default.nix with base configuration. All service instances require explicit module declarations (module.name, module.input). Expected vars errors during nix flake check are CORRECT and resolve during deployment. Boot device path (/dev/sda vs /dev/vda) validation deferred to Story 1.4 disko configuration.
      </doc>
    </docs>
    <code>
      <artifact path="~/projects/nix-workspace/test-clan/modules/hosts/hetzner-vm/default.nix" kind="module" symbol="hetzner-vm host configuration" lines="1-23" reason="Existing base configuration from Story 1.3, must be enhanced with srvos hardening and networking for Story 1.4. Already imports base/nix-settings.nix, has hostname and stateVersion set.">
      </artifact>
      <artifact path="~/projects/nix-workspace/test-clan/modules/flake-parts/clan.nix" kind="module" symbol="clan inventory" lines="14-26" reason="Defines inventory.machines with hetzner-vm and gcp-vm entries created in Story 1.3. Story 1.4 references this inventory in terraform null_resource provisioner calling clan machines install hetzner-vm.">
      </artifact>
      <artifact path="~/projects/nix-workspace/test-clan/modules/base/nix-settings.nix" kind="module" symbol="nix base settings" lines="1-19" reason="Base module already imported by hetzner-vm, provides experimental-features and trusted-users configuration.">
      </artifact>
      <artifact path="~/projects/nix-workspace/clan-infra/modules/terranix/vultr.nix" kind="reference" symbol="SSH key terraform pattern" lines="1-25" reason="Proven pattern from clan-infra: tls_private_key.ssh_deploy_key for terraform deployment key, local_sensitive_file for storing private key, vultr_ssh_key resources. Adapt for Hetzner hcloud_ssh_key.">
      </artifact>
      <artifact path="~/projects/nix-workspace/clan-infra/modules/flake-module.nix" kind="reference" symbol="srvos nixosModules pattern" lines="10-32,34-47" reason="Pattern for importing srvos modules: inputs.srvos.nixosModules.server for base hardening, hardware-specific modules like hardware-hetzner-online-amd, mixins-nix-experimental for experimental features.">
      </artifact>
      <artifact path="~/projects/nix-workspace/clan-infra/machines/web01/disko.nix" kind="reference" symbol="disko structure example" lines="1-115" reason="Reference for disko configuration structure (uses ZFS). Story 1.4 needs simpler LUKS pattern: gpt partitions with EFI boot (type EF00, vfat, 512MB) and LUKS encrypted root (type filesystem luks, ext4 or btrfs inside).">
      </artifact>
      <artifact path="~/projects/nix-workspace/test-clan/flake.nix" kind="config" symbol="flake inputs" lines="1-51" reason="Already has terranix, disko, and srvos inputs configured with follows. terranix.flakeModule must be imported in modules/flake-parts/clan.nix (already done in line 4).">
      </artifact>
    </code>
    <dependencies>
      <ecosystem name="nix">
        <package name="nixpkgs" version="unstable" reason="Base NixOS packages"/>
        <package name="clan-core" version="main" reason="Clan inventory system, vars generators, service instances"/>
        <package name="terranix" version="latest" reason="Nix DSL for terraform configuration generation"/>
        <package name="disko" version="latest" reason="Declarative disk partitioning with LUKS encryption support"/>
        <package name="srvos" version="latest" reason="Server hardening modules (nixosModules.server, hardware modules)"/>
        <package name="flake-parts" version="latest" reason="Modular flake structure"/>
      </ecosystem>
      <ecosystem name="terraform">
        <package name="opentofu" version="latest" reason="Terraform-compatible with state encryption support"/>
        <package name="hcloud" version="latest" reason="Hetzner Cloud provider for VM provisioning"/>
        <package name="tls" version="latest" reason="Generate SSH deployment keys"/>
        <package name="null" version="latest" reason="null_resource provisioner for clan machines install"/>
        <package name="external" version="latest" reason="Fetch clan secrets via data.external shell script"/>
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    - Story 1.4 works in test-clan repository (~/projects/nix-workspace/test-clan), NOT infra repository
    - Must ENHANCE existing modules/hosts/hetzner-vm/default.nix, not recreate it (created in Story 1.3)
    - LUKS encryption is non-negotiable for cloud VMs (security requirement)
    - Follow clan-infra terranix patterns exactly: modules/terranix/base.nix with data.external for secrets, terranixConfigurations in machines/flake-module.nix (if exists) or modules/flake-parts/clan.nix
    - Use Hetzner hcloud provider (NOT vultr) - adapt vultr.nix SSH key pattern to hcloud_ssh_key
    - Hetzner API token MUST be stored as clan secret: clan secrets set hetzner-api-token (manual step, agent must pause)
    - OpenTofu state encryption via tf-passphrase secret: TF_VAR_passphrase and TF_ENCRYPTION in terraformWrapper.prefixText
    - null_resource provisioner must call: clan machines install hetzner-vm (references inventory machine from Story 1.3)
    - Expected vars errors during nix flake check are CORRECT - vars generate during deployment, not at build time
    - Boot device path (/dev/sda vs /dev/vda) must be validated in disko configuration - Hetzner may use either depending on virtualization
    - Use CX22 or CX32 VM size for testing (2-4 vCPU, cost ~â‚¬5-8/month)
    - Story 1.4 prepares configuration but does NOT deploy yet (deployment is Story 1.5)
    - Must support manual secret setup: agent pauses after creating secret-fetching infrastructure, waits for user to configure real Hetzner API token
  </constraints>
  <interfaces>
    <interface name="terranix.flakeModule" kind="flake module import" signature="inputs.terranix.flakeModule" path="modules/flake-parts/clan.nix:4">
      Already imported. Provides perSystem.terranix interface for terranixConfigurations.
    </interface>
    <interface name="perSystem.terranix" kind="flake-parts output" signature="perSystem.terranix.terranixConfigurations.terraform = { workdir, modules, terraformWrapper }">
      Define in modules/flake-parts/clan.nix after imports block. Must include terraformWrapper.package (opentofu.withPlugins), terraformWrapper.extraRuntimeInputs (clan CLI), terraformWrapper.prefixText (fetch secrets, export TF_ENCRYPTION).
    </interface>
    <interface name="data.external" kind="terraform data source" signature="data.external.hetzner-api-token = { program = [ (lib.getExe (pkgs.writeShellApplication { ... })) ]; }">
      Pattern from clan-infra for fetching clan secrets in terraform. Script outputs JSON: { "secret": "value" }. Reference as: config.data.external.hetzner-api-token "result.secret"
    </interface>
    <interface name="clan.core.vars.generators" kind="clan vars API" signature="clan.core.vars.generators.luks-password = { script, files }">
      Disko LUKS encryption needs passphrase from clan vars. Define generator producing password file, reference in disko keyFile configuration.
    </interface>
    <interface name="srvos.nixosModules" kind="nix module imports" signature="imports = [ inputs.srvos.nixosModules.server inputs.srvos.nixosModules.hardware-hetzner-cloud ]">
      Import in modules/hosts/hetzner-vm/default.nix for server hardening baseline. Check srvos repo for Hetzner-specific hardware modules.
    </interface>
    <interface name="disko.devices" kind="disko API" signature="disko.devices.disk.main = { type = disk; device = /dev/sda; content = { type = gpt; partitions = { ... } } }">
      Define in modules/hosts/hetzner-vm/disko.nix. Must have EFI boot partition (512MB vfat) and LUKS root partition with keyFile pointing to clan vars generator output.
    </interface>
  </interfaces>
  <tests>
    <standards>
      Testing approach for Story 1.4 follows declarative infrastructure validation patterns:

      1. Flake evaluation: nix flake check validates all modules evaluate without errors (expected to fail on missing vars - this is CORRECT behavior, vars generate during deployment)

      2. Configuration builds: nix build .#nixosConfigurations.hetzner-vm.config.system.build.toplevel validates NixOS configuration compiles successfully

      3. Terraform generation: nix build .#terranix.terraform (or nix run .#terraform -- version) validates terranix configuration produces valid terraform

      4. Manual terraform review: Inspect generated terraform.tf.json for correctness (hcloud provider, server resource, null_resource provisioner)

      5. Disko evaluation: nix eval .#nixosConfigurations.hetzner-vm.config.disko.disks --apply toString validates disko configuration structure

      No automated deployment tests in Story 1.4 - configuration preparation only. Story 1.5 performs actual deployment and validation.
    </standards>
    <locations>
      - ~/projects/nix-workspace/test-clan (repository root for all commands)
      - modules/terranix/ (terraform configuration modules)
      - modules/hosts/hetzner-vm/ (NixOS host configuration and disko)
      - Generated terraform output: result/terraform.tf.json (after nix build .#terranix.terraform)
    </locations>
    <ideas>
      - AC #9: Test terraform configuration generates successfully (nix build .#terranix.terraform should succeed)
      - AC #10: Manually review terraform.tf.json structure (verify hcloud provider present, server resource configured, SSH key defined, null_resource provisioner calling clan machines install)
      - AC #11: Test host configuration builds without errors (nix build .#nixosConfigurations.hetzner-vm.config.system.build.toplevel)
      - AC #12: Test disko configuration evaluates correctly (nix eval .#nixosConfigurations.hetzner-vm.config.disko.disks --apply toString should show LUKS and partition structure)
      - AC #13: Boot device path validation test: Check disko.nix uses correct device path (/dev/sda or /dev/vda) - document assumption, validate during Story 1.5 deployment
      - Integration test idea: nix flake check --all-systems (will fail on missing vars but should not have evaluation errors in module structure)
      - Secret structure test: Verify clan secrets initialized (clan secrets list should show sops directory exists), verify hetzner-api-token can be retrieved after manual setup
      - Configuration consistency test: Verify modules/hosts/hetzner-vm/default.nix imports disko module, verify terranix references hetzner-vm inventory machine
    </ideas>
  </tests>
</story-context>
