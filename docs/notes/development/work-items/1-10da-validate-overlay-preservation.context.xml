<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.10DA</storyId>
    <title>Validate Overlay Architecture Preservation with pkgs-by-name Integration</title>
    <status>backlog</status>
    <generatedAt>2025-11-16</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/notes/development/work-items/1-10da-validate-overlay-preservation.md</sourceStoryPath>
    <dependencies>
      <dependency>1.10D</dependency>
    </dependencies>
    <estimatedEffort>1.5-2 hours</estimatedEffort>
  </metadata>

  <story>
    <asA>system administrator</asA>
    <iWant>to validate that infra's overlay architecture (multi-channel access, hotfixes, overrides, flake input overlays) is preserved when integrating with pkgs-by-name pattern</iWant>
    <soThat>Epic 2-6 migration maintains ALL infra overlay features (stable fallbacks, hotfixes, build customizations) while gaining pkgs-by-name benefits</soThat>
    <context>
      Story 1.10D validated Layer 3 (custom packages) migration to pkgs-by-name-for-flake-parts.
      This story validates Layers 1, 2, 4, 5 (overlay architecture) are preserved and functional alongside pkgs-by-name.
      Option C staged validation ensures clear separation: Story 1.10D validates Layer 3 in isolation, Story 1.10DA validates overlay preservation (Layers 1,2,4,5), combined achieving 100% of 5-layer architecture validation.
    </context>
    <tasks>
      <taskGroup id="1" name="Overlay Layer Documentation" effort="1h 30min">
        <task id="1.1" name="Document multi-channel access (AC A)" effort="30min">
          - Read overlays/inputs.nix pattern
          - Test stable channel access in test-clan context
          - Test unstable channel access in test-clan context
          - Confirm multi-channel works alongside pkgs-by-name packages
          - Document multi-channel pattern in Section 13.2
        </task>
        <task id="1.2" name="Document hotfixes layer (AC B)" effort="20min">
          - Review overlays/infra/hotfixes.nix pattern
          - Document platform-specific fallback pattern
          - Verify compatibility with pkgs-by-name
          - Document hotfix pattern in Section 13.2
        </task>
        <task id="1.3" name="Document overrides layer (AC C)" effort="20min">
          - Review overlays/overrides/default.nix pattern
          - Document per-package override pattern using overrideAttrs
          - Verify compatibility with pkgs-by-name
          - Document override pattern in Section 13.2
        </task>
        <task id="1.4" name="Document flake input overlays (AC D)" effort="20min">
          - Review flakeInputs overlay pattern in infra
          - Document flake input overlay examples (nuenv, jj)
          - Verify compatibility with pkgs-by-name
          - Document flake input overlay pattern in Section 13.2
        </task>
      </taskGroup>
      <taskGroup id="2" name="Integration Validation" effort="20min">
        <task id="2.1" name="Verify drupol hybrid pattern (AC E)" effort="10min">
          - Read drupol-dendritic-infra modules/flake-parts/nixpkgs.nix (lines 19-37)
          - Document overlays array + pkgsDirectory pattern
          - Confirm coexistence proof (both in same perSystem)
          - Verify pattern applicable to test-clan architecture
        </task>
        <task id="2.2" name="Test all 5 layers functional (AC E)" effort="10min">
          - Layer 1: Multi-channel access (pkgs.stable.*, pkgs.unstable.*)
          - Layer 2: Hotfixes pattern valid
          - Layer 3: pkgs-by-name packages working (Story 1.10D)
          - Layer 4: Overrides pattern valid
          - Layer 5: Flake input overlays valid
          - Document integration validation in Section 13.2
        </task>
      </taskGroup>
      <taskGroup id="3" name="Documentation" effort="30min">
        <task id="3.1" name="Create Section 13.2 structure (AC F)" effort="10min">
          - Open test-clan-validated-architecture.md
          - Create Section 13.2: Overlay Architecture Preservation
          - Add subsections: 5-Layer Model, Layer details, Hybrid Architecture, Migration Strategy, References
        </task>
        <task id="3.2" name="Document 5-layer model with examples (AC F)" effort="15min">
          - Create 5-layer architecture table
          - Document each layer with code examples
          - Add usage guidance (when to use each layer)
          - Include drupol hybrid pattern code example
          - Explain overlay + pkgs-by-name coexistence
        </task>
        <task id="3.3" name="Link references and Epic 2-6 strategy (AC F)" effort="5min">
          - Document overlay preservation strategy (Layers 1,2,4,5 as-is)
          - Document custom package migration strategy (Layer 3 to pkgs-by-name)
          - Link to drupol reference implementation
          - Link to infra overlay architecture files
        </task>
      </taskGroup>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="A" title="Validate Multi-Channel Access (Layer 1)" effort="30min">
      <description>
        Document and validate multi-channel access pattern preserves alongside pkgs-by-name.

        Implementation steps:

        1. Document overlays/inputs.nix pattern providing multi-channel access (stable, patched, unstable)
        2. Test stable channel access in test-clan context (pkgs.stable.* references)
        3. Test unstable channel access in test-clan context (pkgs.unstable.* explicit references)
        4. Confirm multi-channel access works alongside pkgs-by-name packages (no conflicts)
        5. Document multi-channel access pattern in Section 13.2 of test-clan-validated-architecture.md

        Pass criteria:
        - Multi-channel access pattern documented (stable, unstable, patched)
        - Channel access verified in test-clan context (evaluation commands work)
        - No conflicts with pkgs-by-name packages (ccstatusline + stable/unstable coexist)
        - Code examples provided for common use cases
        - Section 13.2 includes multi-channel documentation
      </description>
    </criterion>

    <criterion id="B" title="Validate Hotfixes Layer (Layer 2)" effort="20min">
      <description>
        Document and validate hotfixes pattern preserves alongside pkgs-by-name.

        Implementation steps:

        1. Review overlays/infra/hotfixes.nix pattern (platform-specific stable fallbacks)
        2. Document hotfix pattern: when unstable breaks, fallback to pkgs.stable.* version
        3. Verify hotfix pattern is compatible with pkgs-by-name integration (no conflicts)
        4. Document hotfix preservation strategy in Section 13.2

        Pass criteria:
        - Hotfixes pattern documented (platform-specific stable fallbacks)
        - Platform detection logic explained (isDarwin, isLinux, etc.)
        - Compatibility with pkgs-by-name verified (no conflicts)
        - Code examples provided for common scenarios
        - Section 13.2 includes hotfix documentation
      </description>
    </criterion>

    <criterion id="C" title="Validate Overrides Layer (Layer 4)" effort="20min">
      <description>
        Document and validate overrides pattern preserves alongside pkgs-by-name.

        Implementation steps:

        1. Review overlays/overrides/ pattern (per-package build modifications using overrideAttrs)
        2. Document override pattern examples (build flags, test disabling, dependency patches)
        3. Verify override pattern is compatible with pkgs-by-name integration (no conflicts)
        4. Document override preservation strategy in Section 13.2

        Pass criteria:
        - Overrides pattern documented (per-package build modifications)
        - Common use cases documented with code examples
        - Compatibility with pkgs-by-name verified (can override custom packages)
        - Code examples provided for overrideAttrs patterns
        - Section 13.2 includes override documentation
      </description>
    </criterion>

    <criterion id="D" title="Validate Flake Input Overlays (Layer 5)" effort="20min">
      <description>
        Document and validate flake input overlays preserve alongside pkgs-by-name.

        Implementation steps:

        1. Review flakeInputs overlay pattern (overlays from inputs.nuenv, inputs.jj, etc.)
        2. Document flake input overlay examples (nuenv devshell overlay, jujutsu VCS overlay)
        3. Verify flake input overlays are compatible with pkgs-by-name integration (no conflicts)
        4. Document flake input overlay preservation strategy in Section 13.2

        Pass criteria:
        - Flake input overlay pattern documented (external overlay integration)
        - Example overlays documented (nuenv, jujutsu)
        - Compatibility with pkgs-by-name verified (no conflicts)
        - Code examples provided for adding new flake input overlays
        - Section 13.2 includes flake input overlay documentation
      </description>
    </criterion>

    <criterion id="E" title="Integration Validation (Hybrid Architecture)" effort="20min">
      <description>
        Validate drupol hybrid pattern (overlays + pkgs-by-name) applicable to test-clan.

        Implementation steps:

        1. Verify drupol hybrid pattern (overlays array + pkgsDirectory) applicable to test-clan
        2. Document how overlays array and pkgsDirectory coexist in same perSystem configuration
        3. Test no conflicts between overlay merging and pkgs-by-name auto-discovery
        4. Confirm ALL 5 layers functional in test-clan (multi-channel, hotfixes, custom packages, overrides, flake inputs)
        5. Document hybrid architecture integration in Section 13.2

        Pass criteria:
        - drupol hybrid pattern analyzed (overlays array + pkgsDirectory coexist)
        - Pattern applicable to test-clan confirmed (no architectural blockers)
        - No conflicts between overlays and pkgs-by-name (orthogonal concerns)
        - All 5 layers functional in test-clan context
        - Section 13.2 includes hybrid architecture documentation
      </description>
    </criterion>

    <criterion id="F" title="Documentation - Section 13.2: Overlay Architecture Preservation" effort="30min">
      <description>
        Create comprehensive overlay preservation guide in test-clan-validated-architecture.md.

        Implementation steps:

        1. Create Section 13.2 "Overlay Architecture Preservation" in test-clan-validated-architecture.md
        2. Document 5-layer architecture model with descriptions (inputs, hotfixes, packages, overrides, flakeInputs)
        3. Explain overlay + pkgs-by-name coexistence using drupol hybrid pattern
        4. Provide code examples for each overlay layer:
           - Multi-channel access: pkgs.stable.packageName vs pkgs.unstable.packageName
           - Hotfixes: stable.packageName fallback when unstable breaks
           - Overrides: overrideAttrs pattern for build modifications
           - Flake input overlays: nuenv devshell overlay, jujutsu VCS overlay
        5. Document Epic 2-6 migration strategy: overlays preserved as-is, custom packages migrate to pkgs-by-name
        6. Link to drupol reference implementation and infra overlay architecture files

        Pass criteria:
        - Section 13.2 created in test-clan-validated-architecture.md
        - 5-layer model table present with descriptions
        - Each layer documented with code examples
        - drupol hybrid pattern explained with code
        - Epic 2-6 migration strategy documented
        - References linked (drupol, infra overlays, external)
      </description>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <artifact>
        <path>docs/notes/development/epics/epic-1-architectural-validation-migration-pattern-rehearsal-phase-0.md</path>
        <title>Epic 1 Definition - Story 1.10DA Section</title>
        <section>Story 1.10DA: Validate Overlay Architecture Preservation with pkgs-by-name Integration</section>
        <lines>1364-1478</lines>
        <snippet>
          Story 1.10DA validates infra's overlay architecture (multi-channel access, hotfixes, overrides, flake input overlays) is preserved when integrating with pkgs-by-name pattern. Includes 5-layer architecture model, acceptance criteria, strategic value, and references.
        </snippet>
      </artifact>

      <artifact>
        <path>docs/notes/development/work-items/1-10da-validate-overlay-preservation.md</path>
        <title>Story 1.10DA Work Item</title>
        <section>Complete Work Item Definition</section>
        <lines>1-1401</lines>
        <snippet>
          Comprehensive work item created from Party Mode Option C validation. Includes story description, implementation notes for all 5 overlay layers, 6 acceptance criteria, 3 task groups, dev notes with architectural context, testing standards, and quick reference.
        </snippet>
      </artifact>

      <artifact>
        <path>docs/notes/development/work-items/1-10d-validate-custom-package-overlays.md</path>
        <title>Story 1.10D Work Item (Foundation)</title>
        <section>Layer 3 Validation Foundation</section>
        <snippet>
          Story 1.10D validated Layer 3 (custom packages) migration to pkgs-by-name-for-flake-parts. Status: done. Provides foundation for Story 1.10DA overlay preservation validation (Layers 1,2,4,5).
        </snippet>
      </artifact>

      <artifact>
        <path>overlays/default.nix</path>
        <title>Overlay Architecture Composition</title>
        <section>5-Layer Architecture Documentation</section>
        <lines>1-77</lines>
        <snippet>
          Documents infra's 5-layer overlay architecture: 1) inputs (multi-channel), 2) hotfixes (stable fallbacks), 3) packages (custom derivations), 4) overrides (build modifications), 5) flakeInputs (external overlays). Shows merge order and layer composition using lib.mergeAttrsList.
        </snippet>
      </artifact>
    </docs>

    <code>
      <artifact>
        <path>overlays/default.nix</path>
        <kind>overlay-composition</kind>
        <symbol>lib.mergeAttrsList [inputs' hotfixes packages overrides flakeInputs]</symbol>
        <lines>1-77</lines>
        <reason>
          Core 5-layer architecture implementation. Shows how all overlay layers are composed via lib.mergeAttrsList with explicit merge order. Essential for understanding how layers interact and why preservation strategy works.
        </reason>
      </artifact>

      <artifact>
        <path>overlays/inputs.nix</path>
        <kind>overlay-layer-1</kind>
        <symbol>Multi-channel access (stable, patched, unstable)</symbol>
        <lines>1-58</lines>
        <reason>
          Layer 1 implementation. Provides pkgs.stable, pkgs.patched, pkgs.unstable namespaces using lib'.systemInput for OS-specific channel selection. Critical for AC A validation.
        </reason>
      </artifact>

      <artifact>
        <path>overlays/infra/hotfixes.nix</path>
        <kind>overlay-layer-2</kind>
        <symbol>Platform-specific stable fallbacks</symbol>
        <lines>1-51</lines>
        <reason>
          Layer 2 implementation. Uses final.stable.* fallbacks when unstable packages break on specific platforms (isDarwin, isLinux, etc.). Example: micromamba hotfix for fmt compatibility. Critical for AC B validation.
        </reason>
      </artifact>

      <artifact>
        <path>overlays/overrides/default.nix</path>
        <kind>overlay-layer-4</kind>
        <symbol>Auto-import per-package overrides</symbol>
        <lines>1-36</lines>
        <reason>
          Layer 4 implementation. Auto-imports all *.nix files in overrides/ directory, each providing overrideAttrs modifications for build customization. Critical for AC C validation.
        </reason>
      </artifact>

      <artifact>
        <path>overlays/default.nix</path>
        <kind>overlay-layer-5</kind>
        <symbol>flakeInputs (nuenv overlay)</symbol>
        <lines>44-65</lines>
        <reason>
          Layer 5 implementation. Shows flake input overlay integration pattern using inputs.nuenv.overlays.nuenv. Documents jujutsu overlay disabled due to CI disk constraints. Critical for AC D validation.
        </reason>
      </artifact>

      <artifact>
        <path>~/projects/nix-workspace/drupol-dendritic-infra/modules/flake-parts/nixpkgs.nix</path>
        <kind>reference-pattern</kind>
        <symbol>overlays array + pkgsDirectory hybrid pattern</symbol>
        <lines>19-37</lines>
        <reason>
          Drupol hybrid pattern proof. Shows overlays array (traditional overlays for Layers 1,2,4,5) and pkgsDirectory (pkgs-by-name for Layer 3) coexist in same perSystem configuration. Essential for AC E integration validation.
        </reason>
      </artifact>

      <artifact>
        <path>~/projects/nix-workspace/test-clan/docs/architecture/test-clan-validated-architecture.md</path>
        <kind>documentation-target</kind>
        <symbol>Section 13.2 target</symbol>
        <reason>
          Documentation target for AC F. Section 13.2 "Overlay Architecture Preservation" will be created here with 5-layer model, code examples, drupol hybrid pattern, and Epic 2-6 migration strategy.
        </reason>
      </artifact>
    </code>

    <dependencies>
      <note>
        This is a documentation and validation story. No package dependencies beyond what exists in infra's overlay architecture (nixpkgs, nix ecosystem).
        All code artifacts already exist in infra production configuration.
      </note>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="1" title="5-Layer Architecture Model">
      infra's overlay architecture consists of 5 orthogonal layers merged via lib.mergeAttrsList:

      1. inputs (overlays/inputs.nix) - Multi-channel nixpkgs access (stable, patched, unstable)
      2. hotfixes (overlays/infra/hotfixes.nix) - Platform-specific stable fallbacks for broken unstable packages
      3. packages (overlays/packages/) - Custom derivations [MIGRATED to pkgs-by-name in Story 1.10D]
      4. overrides (overlays/overrides/) - Per-package build modifications using overrideAttrs
      5. flakeInputs - Overlays from flake inputs (nuenv, jujutsu, etc.)

      Each layer is independent and composable. Merge order matters: later layers can reference earlier layers.
    </constraint>

    <constraint id="2" title="Story 1.10DA Scope: Validation Only (NOT Migration)">
      This story validates Layers 1,2,4,5 preservation alongside pkgs-by-name (Layer 3).

      DO:
      - Document each overlay layer (what, how, why)
      - Verify no conflicts with pkgs-by-name (Layer 3 from Story 1.10D)
      - Prove drupol hybrid pattern applicable to test-clan
      - Create Section 13.2: Comprehensive overlay preservation guide

      DO NOT:
      - Migrate overlay files to test-clan
      - Modify infra overlay architecture
      - Change any overlay layer implementations

      Epic 2-6 will migrate infra using these validated patterns.
    </constraint>

    <constraint id="3" title="Story 1.10D Foundation Dependency">
      Story 1.10D (DONE) provides Layer 3 foundation:
      - pkgs-by-name pattern validated for custom packages
      - ccstatusline package functional in test-clan
      - pkgs-by-name-for-flake-parts integration working

      Story 1.10DA AC E (integration validation) depends on Story 1.10D success.
      Cannot validate ALL 5 layers functional without Layer 3 working.
    </constraint>

    <constraint id="4" title="drupol Hybrid Pattern">
      drupol-dendritic-infra modules/flake-parts/nixpkgs.nix (lines 19-37) proves overlays + pkgs-by-name coexist:

      perSystem = {
        _module.args.pkgs = import inputs.nixpkgs {
          overlays = [ ... ];  # Traditional overlays (Layers 1,2,4,5)
        };
        pkgsDirectory = ../../pkgs/by-name;  # pkgs-by-name (Layer 3)
      };

      Both configured in same perSystem block. No conflicts between overlay merging and auto-discovery.
      This pattern MUST be replicated accurately in Section 13.2 documentation.
    </constraint>

    <constraint id="5" title="Preservation Strategy (NOT Migration)">
      Story 1.10DA validates preservation, NOT migration:

      - Layers 1,2,4,5: Keep overlays as-is (no changes needed)
      - Layer 3: Already migrated to pkgs-by-name in Story 1.10D
      - Integration: Validate no conflicts between overlay layers and pkgs-by-name

      Documentation must emphasize preservation (overlays remain unchanged in Epic 2-6 migration).
      Only Layer 3 (custom packages) migrates from overlays/packages/ to pkgs/by-name/.
    </constraint>

    <constraint id="6" title="Documentation Scope: Section 13.2 Comprehensive">
      Section 13.2 must be comprehensive - Epic 2-6 teams depend on it:

      Required content:
      - 5-layer architecture table (layer, purpose, implementation, files)
      - Code examples for EACH layer (multi-channel, hotfixes, overrides, flake inputs)
      - drupol hybrid pattern code example (overlays array + pkgsDirectory)
      - Epic 2-6 migration strategy (preserve overlays, migrate packages)
      - References (drupol, infra overlays, pkgs-by-name-for-flake-parts)

      Quality standard: Self-contained tutorial (developer can implement without additional research).
    </constraint>

    <constraint id="7" title="Option C Staged Validation">
      Option C staged validation approach (Party Mode 2025-11-16):

      - Story 1.10D: Validate Layer 3 (pkgs-by-name) - DONE
      - Story 1.10DA: Validate Layers 1,2,4,5 (overlay preservation) - THIS STORY
      - Combined: 100% of 5-layer architecture validated

      Clear separation of concerns:
      - Story 1.10D: pkgs-by-name pattern validation (isolation)
      - Story 1.10DA: Overlay preservation validation (alongside pkgs-by-name)

      This staged approach provides better test isolation and incremental validation.
    </constraint>

    <constraint id="8" title="Epic 1 Completion: 95% Coverage">
      Story 1.10DA completes Epic 1 to 95% architectural coverage:

      - ALL 5 overlay layers validated (inputs, hotfixes, packages, overrides, flakeInputs)
      - Hybrid architecture validated (overlays + pkgs-by-name coexist)
      - Epic 2-6 migration path clear (preserve overlays, migrate packages)

      Epic 1 completion checkpoint: Ensures ALL 5 overlay layers validated before Epic 2-6 GO decision.
      Incomplete validation = Epic 2-6 blocked (risk of feature loss during migration).
    </constraint>
  </constraints>
  <interfaces>
    <interface id="multi-channel-access" name="Layer 1: Multi-Channel Access Pattern">
      <kind>overlay-pattern</kind>
      <signature>
        # overlays/inputs.nix pattern
        final: prev: {
          stable = import (lib'.systemInput {
            inherit os;
            name = "nixpkgs";
            channel = "stable";
          }) nixpkgsConfig;

          unstable = import inputs.nixpkgs nixpkgsConfig;
        }
      </signature>
      <path>overlays/inputs.nix</path>
      <usage>
        # Access stable channel explicitly
        pkgs.stable.hello      # Stable version for production

        # Access unstable channel explicitly
        pkgs.unstable.hello    # Latest version for development

        # Mix channels in same configuration
        home.packages = [
          pkgs.stable.firefox    # Stable for production reliability
          pkgs.unstable.vscode   # Latest for development features
        ];
      </usage>
    </interface>

    <interface id="hotfix-pattern" name="Layer 2: Hotfix Pattern">
      <kind>overlay-pattern</kind>
      <signature>
        # overlays/infra/hotfixes.nix pattern
        final: prev: {
          # When unstable package breaks on specific platform, fallback to stable
          packageName =
            if pkgs.stdenv.isDarwin &amp;&amp; pkgs.stdenv.isAarch64
            then pkgs.stable.packageName  # Use stable fallback on darwin-aarch64
            else pkgs.packageName;         # Use unstable elsewhere
        }
      </signature>
      <path>overlays/infra/hotfixes.nix</path>
      <usage>
        # Platform-specific hotfix example (from infra)
        inherit (final.stable)
          micromamba  # fmt library compatibility issue in unstable
          ;

        # Pattern: Use stable fallback when unstable breaks
        # Document with hydra link and TODO for removal when fixed
      </usage>
    </interface>

    <interface id="override-pattern" name="Layer 4: Override Pattern">
      <kind>overlay-pattern</kind>
      <signature>
        # overlays/overrides/ pattern
        final: prev: {
          packageName = prev.packageName.overrideAttrs (oldAttrs: {
            # Disable tests (common override)
            doCheck = false;

            # Add patch
            patches = oldAttrs.patches or [] ++ [ ./fix-build.patch ];

            # Modify dependencies
            buildInputs = oldAttrs.buildInputs ++ [ final.extraDep ];
          });
        }
      </signature>
      <path>overlays/overrides/</path>
      <usage>
        # Disable tests
        somePackage = prev.somePackage.overrideAttrs (old: {
          doCheck = false;
        });

        # Apply upstream patch
        anotherPackage = prev.anotherPackage.overrideAttrs (old: {
          patches = old.patches or [] ++ [
            (prev.fetchpatch {
              url = "https://github.com/upstream/pr/123.patch";
              hash = "sha256-...";
            })
          ];
        });
      </usage>
    </interface>

    <interface id="flake-input-overlay" name="Layer 5: Flake Input Overlay Pattern">
      <kind>overlay-pattern</kind>
      <signature>
        # flake.nix inputs
        inputs = {
          nuenv.url = "github:DavHau/nuenv";
          jj.url = "github:martinvonz/jj";
        };

        # overlays/default.nix flakeInputs layer
        flakeInputs = lib.mergeAttrsList [
          (inputs.nuenv.overlays.default final prev)
          (inputs.jj.overlays.default final prev)
        ];
      </signature>
      <path>overlays/default.nix (flakeInputs layer)</path>
      <usage>
        # nuenv devshell builder
        pkgs.nuenv.mkScript {
          name = "my-script";
          script = ''
            # Nushell script here
          '';
        }

        # jujutsu VCS overlay
        programs.jujutsu.package = pkgs.jujutsu;  # Latest from overlay
      </usage>
    </interface>

    <interface id="drupol-hybrid" name="drupol Hybrid Pattern (Overlays + pkgs-by-name Coexistence)">
      <kind>integration-pattern</kind>
      <signature>
        # drupol-dendritic-infra/modules/flake-parts/nixpkgs.nix (lines 19-37)
        perSystem = { system, ... }: {
          # Traditional overlays array (Layers 1,2,4,5)
          _module.args.pkgs = import inputs.nixpkgs {
            inherit system;
            config = { allowUnfreePredicate = _pkg: true; };
            overlays = [
              # Multi-channel access (Layer 1)
              (final: _prev: {
                stable = import inputs.nixpkgs-stable {
                  inherit (final) config;
                  inherit system;
                };
              })
              (final: _prev: {
                unstable = import inputs.nixpkgs-unstable {
                  inherit (final) config;
                  inherit system;
                };
              })
              # External overlays (Layer 5)
              inputs.nix-webapps.overlays.lib
            ];
          };

          # pkgs-by-name auto-discovery (Layer 3)
          pkgsDirectory = ../../pkgs/by-name;
        };
      </signature>
      <path>~/projects/nix-workspace/drupol-dendritic-infra/modules/flake-parts/nixpkgs.nix</path>
      <usage>
        Why they coexist:
        - Orthogonal concerns: overlays modify pkgs, pkgs-by-name exports custom packages
        - Different mechanisms: overlay merging vs auto-discovery
        - No namespace overlap: pkgs.stable.* vs pkgs.customPackage

        Application to test-clan:
        - Layers 1,2,4,5: Traditional overlays array (preserved from infra)
        - Layer 3: pkgs-by-name auto-discovery (migrated in Story 1.10D)
        - Combined: ALL 5 layers functional, no conflicts
      </usage>
    </interface>
  </interfaces>
  <tests>
    <standards>
      Story 1.10DA is a validation and documentation story, not an implementation story.
      Testing standards focus on documentation completeness and architectural validation rather than code tests.

      Quality Gates:

      1. Infrastructure Documentation (All 4 Overlay Layers):
         - All 4 overlay layers documented (inputs, hotfixes, overrides, flakeInputs)
         - Code examples provided for each layer
         - Implementation files referenced correctly
         - Usage guidance provided (when to use each layer)

      2. Integration Validation (Hybrid Architecture):
         - drupol hybrid pattern analyzed (overlays array + pkgsDirectory)
         - Pattern applicable to test-clan confirmed (no architectural blockers)
         - No conflicts between overlays and pkgs-by-name (orthogonal concerns)
         - All 5 layers functional in test-clan context

      3. Documentation Completeness (Section 13.2):
         - Section 13.2 created in test-clan-validated-architecture.md
         - 5-layer model table present with descriptions
         - Code examples correct and tested
         - Migration strategy clear and actionable
         - References accurate (local paths + external URLs)
    </standards>

    <locations>
      Documentation validation locations:
      - infra overlay files: ~/projects/nix-workspace/infra/overlays/
        * overlays/default.nix - 5-layer composition
        * overlays/inputs.nix - Multi-channel access (Layer 1)
        * overlays/infra/hotfixes.nix - Platform hotfixes (Layer 2)
        * overlays/overrides/ - Package overrides (Layer 4)
      - drupol reference: ~/projects/nix-workspace/drupol-dendritic-infra/modules/flake-parts/nixpkgs.nix (lines 19-37)
      - test-clan target: ~/projects/nix-workspace/test-clan/docs/architecture/test-clan-validated-architecture.md (Section 13.2)
      - Story 1.10D foundation: ~/projects/nix-workspace/test-clan/ (Layer 3 validation)

      Validation commands (test-clan):
      - Multi-channel access: nix eval .#homeConfigurations.aarch64-darwin.crs58.pkgs.stable.hello.version
      - pkgs-by-name package: nix eval .#packages.aarch64-darwin.ccstatusline.meta.description
      - No conflicts: nix flake check
    </locations>

    <ideas>
      AC A (Multi-Channel Access - Layer 1):
      - Validate multi-channel access documented with code examples (stable, unstable, patched)
      - Test stable channel access works in test-clan (nix eval stable.hello.version)
      - Test unstable channel access works in test-clan (nix eval unstable.hello.version)
      - Verify no conflicts between multi-channel and pkgs-by-name (ccstatusline coexists with stable/unstable)
      - Document when to use stable vs unstable (stability vs features trade-off)

      AC B (Hotfixes - Layer 2):
      - Validate hotfix pattern documented (platform-specific stable fallbacks)
      - Document platform detection logic (isDarwin, isLinux, isAarch64)
      - Verify hotfix pattern compatible with pkgs-by-name (no conflicts)
      - Document real example from infra (micromamba hotfix for fmt compatibility)
      - Document best practices (track upstream issues, remove when fixed)

      AC C (Overrides - Layer 4):
      - Validate override pattern documented (per-package build modifications)
      - Document common use cases (doCheck = false, patches, build flags, dependencies)
      - Verify override pattern works with pkgs-by-name packages (can override custom packages)
      - Document overrideAttrs examples (disable tests, add patches, change flags)
      - Document when to use overrides vs hotfixes (customization vs workaround)

      AC D (Flake Input Overlays - Layer 5):
      - Validate flake input overlay pattern documented (external overlay integration)
      - Document example overlays (nuenv devshell, jujutsu VCS)
      - Verify flake input overlays compatible with pkgs-by-name (orthogonal namespaces)
      - Document how to add new flake input overlays (flake.nix inputs â†’ overlays/default.nix)
      - Document modular composition benefits (track upstream, no vendoring)

      AC E (Integration Validation - Hybrid Architecture):
      - Validate drupol hybrid pattern analyzed (overlays array + pkgsDirectory coexist)
      - Verify pattern applicable to test-clan (no architectural blockers)
      - Test no conflicts between overlay merging and pkgs-by-name auto-discovery
      - Verify ALL 5 layers functional in test-clan context:
        * Layer 1: Multi-channel access (pkgs.stable.*, pkgs.unstable.*)
        * Layer 2: Hotfixes pattern valid (platform-specific fallbacks)
        * Layer 3: pkgs-by-name packages working (ccstatusline from Story 1.10D)
        * Layer 4: Overrides pattern valid (overrideAttrs works)
        * Layer 5: Flake input overlays valid (nuenv, jj, etc.)
      - Document hybrid architecture in Section 13.2

      AC F (Documentation - Section 13.2):
      - Validate Section 13.2 created in test-clan-validated-architecture.md
      - Verify 5-layer model table complete (layer, purpose, implementation, files)
      - Validate code examples for each layer (multi-channel, hotfixes, overrides, flake inputs)
      - Verify drupol hybrid pattern explained with code (overlays array + pkgsDirectory)
      - Validate Epic 2-6 migration strategy documented (preserve overlays, migrate packages)
      - Verify references linked correctly (drupol, infra overlays, external URLs)
      - Ensure documentation is self-contained tutorial (developer can implement without research)
    </ideas>
  </tests>
</story-context>
