<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>10DB</storyId>
    <title>Execute Overlay Architecture Migration from infra to test-clan</title>
    <status>drafted</status>
    <generatedAt>2025-11-16</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/notes/development/work-items/1-10db-execute-overlay-architecture-migration.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>system administrator</asA>
    <iWant>to migrate infra's overlay layers (1,2,4,5) to test-clan dendritic flake-parts structure and validate empirically</iWant>
    <soThat>Epic 1 achieves 95% architectural coverage with REAL implementation evidence (not just documentation)</soThat>

    <tasks>
### Task Group 1: Migrate Overlay Layers (AC-A, AC-B, AC-C)
- [ ] 1.1: Create overlay directory structure (AC-A.1)
- [ ] 1.2: Migrate Layer 1 inputs overlay (AC-A.1)
- [ ] 1.3: Import Layer 1 in nixpkgs.nix (AC-A.2)
- [ ] 1.4: Validate Layer 1 multi-channel access (AC-A.3)
- [ ] 1.5: Migrate Layer 2 hotfixes overlay (AC-B.1)
- [ ] 1.6: Import Layer 2 in nixpkgs.nix (AC-B.2)
- [ ] 1.7: Validate Layer 2 platform hotfixes (AC-B.3)
- [ ] 1.8: Migrate Layer 4 overrides overlay (AC-C.1)
- [ ] 1.9: Import Layer 4 in nixpkgs.nix (AC-C.2)
- [ ] 1.10: Validate Layer 4 infrastructure (AC-C.3)

### Task Group 2: Configure Flake Input Overlays (AC-D)
- [ ] 2.1: Add nuenv flake input (AC-D.1)
- [ ] 2.2: Import nuenv overlay in nixpkgs.nix (AC-D.2)
- [ ] 2.3: Validate nuenv accessible (AC-D.3)
- [ ] 2.4: Verify all 5 overlay layers configured

### Task Group 3: Validate and Document (AC-E, AC-F)
- [ ] 3.1: Build all configurations (AC-E.1)
- [ ] 3.2: Inspect merged pkgs (all 5 layers) (AC-E.2)
- [ ] 3.3: Validate zero regressions (AC-E.3)
- [ ] 3.4: Create Section 13.2 structure (AC-F.1)
- [ ] 3.5: Document all 5 layers with empirical evidence (AC-F.2)
- [ ] 3.6: Document build validation and package inspection (AC-F.2)
- [ ] 3.7: Create infra migration guide (AC-F.2)
- [ ] 3.8: Document lessons learned (AC-F.2)
- [ ] 3.9: Add references and cross-references (AC-F.2)
- [ ] 3.10: Verify Section 13.2 matches Section 13.1 quality (AC-F.2)
    </tasks>
  </story>

  <acceptanceCriteria>
### AC-A: Migrate Layer 1 (Multi-Channel Access)
**Target:** Migrate infra/overlays/inputs.nix to dendritic structure
**Pass Criteria:**
- File modules/flake-parts/overlays/inputs.nix exists
- Imported in nixpkgs.nix overlays array
- pkgs.stable.* accessible in all configurations
- pkgs.unstable.* accessible in all configurations
- Channels provide different package versions
- Section 13.2 Layer 1 documented with validation evidence

### AC-B: Migrate Layer 2 (Hotfixes)
**Target:** Migrate infra/overlays/infra/hotfixes.nix to dendritic structure
**Pass Criteria:**
- File modules/flake-parts/overlays/hotfixes.nix exists
- Imported in nixpkgs.nix overlays array (after Layer 1)
- micromamba uses stable version (verify version number)
- Hotfix successfully overrides unstable package
- Section 13.2 Layer 2 documented with validation evidence

### AC-C: Migrate Layer 4 (Overrides)
**Target:** Migrate infra/overlays/overrides/default.nix infrastructure
**Pass Criteria:**
- File modules/flake-parts/overlays/overrides.nix exists
- Imported in nixpkgs.nix overlays array (after Layer 2)
- Overlay infrastructure evaluates successfully
- All builds pass with overrides overlay active
- Section 13.2 Layer 4 documented with pattern explanation

### AC-D: Configure Layer 5 (Flake Input Overlays)
**Target:** Integrate flake input overlays into dendritic nixpkgs.nix
**Pass Criteria:**
- nuenv flake input added to flake.nix
- nuenv overlay imported in nixpkgs.nix overlays array (after Layer 4)
- pkgs.nuenv accessible in all configurations
- nuenv.mkScript function available
- Section 13.2 Layer 5 documented with validation evidence

### AC-E: Validate Hybrid Pattern (All 5 Layers Coexist)
**Target:** Prove all 5 overlay layers work together with pkgs-by-name (Story 1.10D Layer 3)
**Pass Criteria:**
- All 4 builds pass (blackphos, cinnabar, crs58, raquel)
- Layer 1: pkgs.stable.* and pkgs.unstable.* accessible
- Layer 2: Hotfixes applied (micromamba uses stable)
- Layer 3: Custom packages from pkgs-by-name (ccstatusline)
- Layer 4: Overrides infrastructure active (no evaluation errors)
- Layer 5: Input overlay packages accessible (nuenv)
- Zero regressions from Story 1.10D (all checks still pass)
- Section 13.2 hybrid pattern documented with empirical evidence

### AC-F: Update Section 13.2 with Empirical Evidence
**Target:** Replace theoretical documentation with empirical implementation evidence matching Section 13.1 quality
**Pass Criteria:**
- Section 13.2 exists in test-clan-validated-architecture.md
- Contains all 5 layer implementations with real code
- Includes build validation commands and outputs
- Documents hybrid pattern integration (overlays + pkgsDirectory)
- Matches Section 13.1 quality (empirical, production-ready)
- Provides Epic 2-6 migration guide with effort estimates
- References infra source files and drupol hybrid pattern
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/notes/development/epics/epic-1-architectural-validation-migration-pattern-rehearsal-phase-0.md</path>
        <title>Epic 1 - Architectural Validation + Migration Pattern Rehearsal</title>
        <section>Story 1.10DB Definition (lines 1481-1639)</section>
        <snippet>Epic 1 context for Story 1.10DB including Option C decision rationale, Party Mode ultrathink findings identifying Story 1.10DA gap (theoretical only, no actual migration), and Story 1.10DB mission (execute ACTUAL overlay migration, validate empirically, prove hybrid pattern).</snippet>
      </doc>

      <doc>
        <path>docs/notes/development/PRD/executive-summary.md</path>
        <title>PRD Executive Summary</title>
        <section>Validation-First De-Risking Strategy</section>
        <snippet>Phase 0 validates untested architectural combination (dendritic + clan) in disposable test environment before production migration. Emphasizes progressive validation gates with explicit go/no-go frameworks.</snippet>
      </doc>

      <doc>
        <path>docs/notes/development/PRD/functional-requirements.md</path>
        <title>PRD Functional Requirements</title>
        <section>FR-1: Architectural Integration (Phase 0 validation)</section>
        <snippet>test-clan repository shall integrate clan-core flakeModules with dendritic flake-parts pattern. Go/no-go decision framework evaluates architectural conflicts before Epic 2-6 migration.</snippet>
      </doc>

      <doc>
        <path>docs/notes/development/architecture/architectural-decisions.md</path>
        <title>Architecture Architectural Decisions</title>
        <section>ADR-001: Adopt Dendritic Flake-Parts + Clan-Core Integration</section>
        <snippet>Dendritic pattern provides type-safety through module system. Clan provides multi-machine coordination. Integration validated in test-clan before infra migration.</snippet>
      </doc>

      <doc>
        <path>docs/notes/development/work-items/1-10d-validate-custom-package-overlays.md</path>
        <title>Story 1.10D - Validate Custom Package Overlays</title>
        <section>Complete Story (Layer 3 pkgs-by-name validation)</section>
        <snippet>Story 1.10D validated Layer 3 (custom packages) migration to pkgs-by-name-for-flake-parts pattern. ccstatusline proof-of-concept complete. Section 13.1 provides empirical tutorial (467 lines). Quality: 9.5/10 clarity. Dev time: ~2h 55min. All 9 ACs satisfied, 4 gates PASS. Story 1.10DB must match this empirical rigor.</snippet>
      </doc>

      <doc>
        <path>docs/notes/development/work-items/1-10da-validate-overlay-preservation.md</path>
        <title>Story 1.10DA - Validate Overlay Preservation</title>
        <section>Option C Staged Validation Rationale</section>
        <snippet>Party Mode team (2025-11-16, 9 agents unanimous) identified Story 1.10D only validated Layer 3 (custom packages). Story 1.10DA provided THEORETICAL documentation for Layers 1,2,4,5 but NO actual migration. Story 1.10DB fills empirical validation gap.</snippet>
      </doc>

      <doc>
        <path>~/projects/nix-workspace/test-clan/docs/architecture/test-clan-validated-architecture.md</path>
        <title>test-clan Validated Architecture</title>
        <section>Section 13.1 - pkgs-by-name Pattern (Story 1.10D reference)</section>
        <snippet>Section 13.1 provides comprehensive pkgs-by-name tutorial based on Story 1.10D empirical validation. 467 lines covering pattern overview, complete implementation, build validation, package inspection, migration guide. Quality baseline for Section 13.2.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>overlays/default.nix</path>
        <kind>overlay composition</kind>
        <symbol>5-layer architecture</symbol>
        <lines>1-77</lines>
        <reason>Documents complete 5-layer overlay architecture with merge order dependencies. Lines 71-77 show lib.mergeAttrsList composition: inputs → hotfixes → packages → overrides → flakeInputs. Critical for understanding layer dependencies.</reason>
      </artifact>

      <artifact>
        <path>overlays/inputs.nix</path>
        <kind>overlay layer 1</kind>
        <symbol>Multi-channel nixpkgs access</symbol>
        <lines>1-59</lines>
        <reason>Layer 1 implementation providing pkgs.stable, pkgs.unstable, pkgs.patched namespaces. Uses overlayArgs pattern ({ flake, ... }:) requiring adaptation for dendritic. Migration target: test-clan/modules/flake-parts/overlays/inputs.nix</reason>
      </artifact>

      <artifact>
        <path>overlays/infra/hotfixes.nix</path>
        <kind>overlay layer 2</kind>
        <symbol>Platform-specific hotfixes</symbol>
        <lines>1-51</lines>
        <reason>Layer 2 implementation using final.stable for broken unstable packages. Pure overlay function (final: prev:) requiring no changes. Migration target: test-clan/modules/flake-parts/overlays/hotfixes.nix. Depends on Layer 1 (needs final.stable).</reason>
      </artifact>

      <artifact>
        <path>overlays/overrides/default.nix</path>
        <kind>overlay layer 4</kind>
        <symbol>Auto-import override infrastructure</symbol>
        <lines>1-37</lines>
        <reason>Layer 4 auto-import infrastructure for per-package overrides. Uses overlayArgs pattern. infra has framework but no actual override files yet. Migration target: test-clan/modules/flake-parts/overlays/overrides.nix (simplified placeholder).</reason>
      </artifact>

      <artifact>
        <path>overlays/default.nix</path>
        <kind>overlay layer 5</kind>
        <symbol>flakeInputs composition</symbol>
        <lines>44-65</lines>
        <reason>Layer 5 showing nuenv overlay integration from flake inputs. Lines 46-47 show nuenv pattern: (inputs.nuenv.overlays.nuenv self super).nuenv. Migration target: test-clan/modules/flake-parts/nixpkgs.nix overlays array.</reason>
      </artifact>

      <artifact>
        <path>~/projects/nix-workspace/drupol-dendritic-infra/modules/flake-parts/nixpkgs.nix</path>
        <kind>reference implementation</kind>
        <symbol>Hybrid pattern proof (overlays + pkgsDirectory)</symbol>
        <lines>11-38</lines>
        <reason>PRIMARY reference proving overlays array + pkgsDirectory coexist in same perSystem. Lines 19-35 show overlays array configuration. Line 37 shows pkgsDirectory configuration. Both in SAME perSystem block. Validates hybrid pattern viable.</reason>
      </artifact>

      <artifact>
        <path>~/projects/nix-workspace/test-clan/pkgs/by-name/ccstatusline/package.nix</path>
        <kind>custom package</kind>
        <symbol>Story 1.10D Layer 3 validation</symbol>
        <lines>all</lines>
        <reason>Story 1.10D proof-of-concept package. Validates Layer 3 (pkgs-by-name pattern) works. Story 1.10DB must ensure all 5 layers coexist with this Layer 3 foundation. Zero regression requirement.</reason>
      </artifact>

      <artifact>
        <path>~/projects/nix-workspace/test-clan/flake.nix</path>
        <kind>flake configuration</kind>
        <symbol>Flake inputs</symbol>
        <lines>all</lines>
        <reason>Target for Layer 5 nuenv flake input addition. Current inputs: nixpkgs, clan-core, pkgs-by-name-for-flake-parts, etc. Need to add inputs.nuenv.url for Layer 5 validation.</reason>
      </artifact>
    </code>

    <dependencies>
      <nix>
        <package>nixpkgs</package>
        <version>unstable (current)</version>
        <reason>Main package set for overlays</reason>
      </nix>

      <nix>
        <package>nixpkgs-darwin-stable</package>
        <version>stable (via inputs)</version>
        <reason>Layer 1 stable channel for darwin</reason>
      </nix>

      <nix>
        <package>nixpkgs-linux-stable</package>
        <version>stable (via inputs)</version>
        <reason>Layer 1 stable channel for linux</reason>
      </nix>

      <nix>
        <package>nuenv</package>
        <version>latest (github:DeterminateSystems/nuenv)</version>
        <reason>Layer 5 flake input overlay for nushell script packaging</reason>
      </nix>

      <nix>
        <package>pkgs-by-name-for-flake-parts</package>
        <version>latest (current in test-clan)</version>
        <reason>Layer 3 custom packages infrastructure (Story 1.10D)</reason>
      </nix>

      <nix>
        <package>clan-core</package>
        <version>latest (current in test-clan)</version>
        <reason>Multi-machine coordination framework</reason>
      </nix>
    </dependencies>
  </artifacts>

  <constraints>
**1. Layer Merge Order Preservation (CRITICAL):**
- Layer 1 (inputs) MUST come first: Provides stable/unstable namespaces for later layers
- Layer 2 (hotfixes) MUST follow Layer 1: Depends on final.stable from Layer 1
- Layer 4 (overrides) MUST follow Layers 1-2: Can reference all prior layer packages
- Layer 5 (flakeInputs) MUST come last: External overlays reference everything
- Incorrect order causes: Evaluation failures, infinite recursion, undefined references
- Validation: nix flake check MUST pass after each layer addition

**2. Hybrid Pattern Integrity (CRITICAL):**
- overlays array handles Layers 1,2,4,5 (traditional overlay functions)
- pkgsDirectory handles Layer 3 (custom packages via auto-discovery)
- Both MUST be configured in SAME perSystem block (drupol pattern)
- Do NOT mix overlay layers into pkgsDirectory or vice versa
- Validation: All 5 layers accessible in merged pkgs, no namespace conflicts

**3. Story 1.10D Regression Prevention (ZERO TOLERANCE):**
- All Story 1.10D validations MUST still pass after overlay migration
- ccstatusline package MUST still build (nix build .#ccstatusline)
- home-module-exports check MUST still pass (nix build .#checks.aarch64-darwin.home-module-exports)
- home-configurations-exposed check MUST still pass (nix build .#checks.aarch64-darwin.home-configurations-exposed)
- Layer 3 (pkgs-by-name) integrity MUST be preserved
- Validation: Run all Story 1.10D validation commands, zero failures tolerated

**4. Empirical Documentation Requirement (MATCHES STORY 1.10D QUALITY):**
- Section 13.2 MUST be based on REAL implementation (not hypothetical)
- All code examples MUST be from ACTUAL migrated overlays
- Build validation MUST include ACTUAL command outputs (not placeholders)
- Lessons learned MUST document REAL challenges encountered during migration
- Quality target: 9.5/10 clarity (matches Story 1.10D Section 13.1)
- Validation: Section 13.2 self-contained tutorial, Epic 2-6 developers can execute migration

**5. Epic 1 Coverage Target (95% ARCHITECTURAL VALIDATION):**
- Story 1.10DB completion achieves 95% Epic 1 architectural coverage
- All 5 overlay layers empirically validated (not just documented)
- Hybrid pattern proven working (overlays + pkgs-by-name coexistence)
- Epic 2-6 teams receive battle-tested migration guide based on real implementation
- No theoretical-only documentation (Party Mode ultrathink decision enforced)
- Validation: GO/NO-GO decision confidence, architectural uncertainty removed
  </constraints>

  <interfaces>
**1. overlayArgs Pattern (infra → dendritic adaptation):**
```nix
# infra pattern (overlays/inputs.nix, overlays/overrides/default.nix):
{ flake, ... }:  # overlayArgs provides flake access
final: prev:
{ ... }

# dendritic adaptation (modules/flake-parts/overlays/inputs.nix):
# Remove { flake, ... }: wrapper
# Pass inputs parameter from nixpkgs.nix import
inputs:  # Parameter from: (import ./overlays/inputs.nix inputs)
final: prev:
{ ... }
```

**2. nixpkgs.nix overlays array integration:**
```nix
# modules/flake-parts/nixpkgs.nix
{ inputs, ... }:
{
  imports = [ inputs.pkgs-by-name-for-flake-parts.flakeModule ];

  perSystem = { system, ... }: {
    _module.args.pkgs = import inputs.nixpkgs {
      inherit system;
      config = { allowUnfree = true; };
      overlays = [
        # Layer 1: Multi-channel access (requires inputs parameter)
        (import ./overlays/inputs.nix inputs)
        # Layer 2: Platform hotfixes (pure overlay, no parameters)
        (import ./overlays/hotfixes.nix)
        # Layer 4: Package overrides (pure overlay)
        (import ./overlays/overrides.nix)
        # Layer 5: Flake input overlays (direct import)
        inputs.nuenv.overlays.nuenv
      ];
    };
    # Layer 3: Custom packages (Story 1.10D)
    pkgsDirectory = ../pkgs/by-name;
  };
}
```

**3. Layer merge order dependencies:**
```nix
# Layer 1 exports (available in Layer 2+):
pkgs.stable.*    # Stable channel packages
pkgs.unstable.*  # Unstable channel packages
pkgs.patched.*   # Patched nixpkgs

# Layer 2 uses Layer 1:
inherit (final.stable) micromamba;  # Requires final.stable from Layer 1

# Layer 4 can reference Layers 1-3:
somePackage = prev.somePackage.overrideAttrs (oldAttrs: {
  # Can reference stable, unstable, custom packages
});

# Layer 5 can reference everything:
# External overlays have access to all prior layers
```

**4. Build validation interface:**
```bash
# All 4 configurations must build:
nix build .#darwinConfigurations.blackphos.system
nix build .#nixosConfigurations.cinnabar.config.system.build.toplevel
nix build .#homeConfigurations.crs58.activationPackage
nix build .#homeConfigurations.raquel.activationPackage

# Layer validation commands:
nix eval .#darwinConfigurations.blackphos.pkgs.stable.hello.version       # Layer 1
nix eval .#darwinConfigurations.blackphos.pkgs.micromamba.version        # Layer 2
nix build .#ccstatusline                                                 # Layer 3
nix eval .#darwinConfigurations.blackphos.pkgs.nuenv.version             # Layer 5

# Regression validation (Story 1.10D):
nix build .#checks.aarch64-darwin.home-module-exports
nix build .#checks.aarch64-darwin.home-configurations-exposed
```

**5. drupol hybrid pattern interface (reference implementation):**
```nix
# drupol-dendritic-infra/modules/flake-parts/nixpkgs.nix lines 11-38
perSystem = { system, ... }: {
  _module.args.pkgs = import inputs.nixpkgs {
    inherit system;
    config = { allowUnfreePredicate = _pkg: true; };
    overlays = [
      # Multi-channel access (similar to infra Layer 1)
      (final: _prev: {
        master = import inputs.nixpkgs-master {
          inherit (final) config;
          inherit system;
        };
      })
      (final: _prev: {
        unstable = import inputs.nixpkgs-unstable {
          inherit (final) config;
          inherit system;
        };
      })
      # External overlays (similar to infra Layer 5)
      inputs.nix-webapps.overlays.lib
    ];
  };
  # Custom packages (similar to infra Layer 3)
  pkgsDirectory = ../../pkgs/by-name;
};
```
  </interfaces>

  <tests>
    <standards>
**Testing Framework:** Nix build system validation (declarative builds prove correctness)

**Test Approach:**
1. **Infrastructure Setup Validation** (Task Group 1)
   - Verify overlay files created in correct locations
   - Verify nixpkgs.nix imports overlay files correctly
   - Verify overlays array ordering matches layer dependencies
   - nix flake check passes after each layer addition

2. **Layer Functionality Validation** (AC-A, AC-B, AC-D)
   - Layer 1: Multi-channel access (stable vs unstable version differences)
   - Layer 2: Hotfixes (micromamba uses stable version, not unstable)
   - Layer 5: Flake input overlays (nuenv package and mkScript accessible)

3. **Hybrid Pattern Integration Validation** (AC-E)
   - All 5 layers accessible in merged pkgs
   - No namespace conflicts between overlay layers
   - pkgs-by-name (Layer 3) still works alongside overlays
   - All 4 configurations build successfully

4. **Regression Testing** (AC-E, ZERO TOLERANCE)
   - Story 1.10D validations still pass (ccstatusline builds)
   - Story 1.10D checks still pass (home-module-exports, home-configurations-exposed)
   - No functionality loss from Story 1.10D Layer 3 work

5. **Documentation Quality Validation** (AC-F)
   - Section 13.2 exists with all required sections
   - Code examples match actual migrated overlay code
   - Build validation commands produce expected outputs
   - Tutorial comprehensive enough for Epic 2-6 teams to execute
   - Quality matches Story 1.10D Section 13.1 (9.5/10 clarity)

**Pass Criteria:**
- All builds succeed (4 configurations)
- All layer validations pass (package inspection confirms)
- Zero regressions (Story 1.10D checks pass)
- Documentation complete and empirical
    </standards>

    <locations>
**Test-clan Repository:** ~/projects/nix-workspace/test-clan/

**Build Targets:**
- .#darwinConfigurations.blackphos.system
- .#nixosConfigurations.cinnabar.config.system.build.toplevel
- .#homeConfigurations.crs58.activationPackage
- .#homeConfigurations.raquel.activationPackage

**Checks:**
- .#checks.aarch64-darwin.home-module-exports (Story 1.10D)
- .#checks.aarch64-darwin.home-configurations-exposed (Story 1.10D)

**Package Builds:**
- .#ccstatusline (Story 1.10D Layer 3 validation)

**Layer Validation Paths:**
- Layer 1: .#darwinConfigurations.blackphos.pkgs.stable.*
- Layer 1: .#darwinConfigurations.blackphos.pkgs.unstable.*
- Layer 2: .#darwinConfigurations.blackphos.pkgs.micromamba
- Layer 3: .#ccstatusline (Story 1.10D)
- Layer 5: .#darwinConfigurations.blackphos.pkgs.nuenv

**Documentation Target:**
- ~/projects/nix-workspace/test-clan/docs/architecture/test-clan-validated-architecture.md
- Section 13.2: Overlay Architecture Preservation with Dendritic Pattern
    </locations>

    <ideas>
**Test Idea 1: Layer 1 Multi-Channel Access Validation (AC-A)**
- Validate pkgs.stable.hello and pkgs.unstable.hello provide different versions
- Prove stable channel older than unstable channel (expected behavior)
- Verify both channels accessible simultaneously (multi-channel pattern works)
- Maps to: AC-A pass criteria

**Test Idea 2: Layer 2 Hotfix Application Validation (AC-B)**
- Validate micromamba uses stable version (not unstable)
- Compare pkgs.micromamba.version to pkgs.stable.micromamba.version (should match)
- Compare pkgs.micromamba.version to pkgs.unstable.micromamba.version (should differ)
- Prove hotfix successfully overrides unstable package
- Maps to: AC-B pass criteria

**Test Idea 3: Layer 5 Flake Input Overlay Validation (AC-D)**
- Validate pkgs.nuenv package exists and evaluates
- Validate pkgs.nuenv.version returns version string
- Validate pkgs.nuenv.mkScript function exists (main nuenv API)
- Prove flake input overlay integrated correctly
- Maps to: AC-D pass criteria

**Test Idea 4: Hybrid Pattern Integration Validation (AC-E)**
- Build all 4 configurations (blackphos, cinnabar, crs58, raquel)
- Inspect merged pkgs for all 5 layers (package inspection commands)
- Verify ccstatusline still builds (Layer 3 from Story 1.10D)
- Verify no namespace conflicts between layers
- Prove all 5 layers coexist with pkgs-by-name
- Maps to: AC-E pass criteria

**Test Idea 5: Zero Regression Validation (AC-E, CRITICAL)**
- Run all Story 1.10D validation commands
- Verify ccstatusline package still builds (nix build .#ccstatusline)
- Verify home-module-exports check still passes
- Verify home-configurations-exposed check still passes
- Prove overlay migration did not break Story 1.10D Layer 3 work
- Maps to: AC-E pass criteria, constraint #3 zero tolerance

**Test Idea 6: Documentation Quality Validation (AC-F)**
- Review Section 13.2 for completeness (all 5 layers documented)
- Verify code examples match actual migrated overlay code (empirical, not hypothetical)
- Execute all build validation commands from Section 13.2 (commands work)
- Compare Section 13.2 quality to Section 13.1 baseline (9.5/10 clarity target)
- Prove Epic 2-6 teams can execute migration guide successfully
- Maps to: AC-F pass criteria, constraint #4 empirical documentation
    </ideas>
  </tests>

  <codeExamples>
## Complete Overlay Layer Implementations (infra source code)

### Layer 1: Multi-Channel Access (overlays/inputs.nix - Complete Implementation)

```nix
# Multi-channel nixpkgs access layer
#
# Exports:
#   - inputs: Raw flake inputs reference
#   - nixpkgs: Main nixpkgs (unstable) - for reference
#   - patched: nixpkgs with patches from infra/patches.nix applied
#   - stable: OS-specific stable nixpkgs (darwin-stable or linux-stable)
#   - unstable: Explicit unstable nixpkgs (same as nixpkgs, for clarity)
#
# Usage in other overlays or configurations:
#   pkgs.stable.packageName       # Get package from stable channel
#   pkgs.patched.packageName      # Get package from patched nixpkgs
#   pkgs.unstable.packageName     # Explicit unstable reference
#
{ flake, ... }:
final: prev:
let
  inherit (flake) inputs;
  # Access lib through inputs.self since nixos-unified's specialArgsFor.common doesn't include lib directly
  lib' = inputs.self.lib;
  os = lib'.systemOs prev.stdenv.hostPlatform.system;

  # Shared nixpkgs configuration
  # Must match configuration in flake.nix perSystem
  nixpkgsConfig = {
    system = prev.stdenv.hostPlatform.system;
    config = {
      allowUnfree = true;
    };
  };
in
{
  # Raw inputs access
  inherit inputs;

  # Main nixpkgs (unstable) - imported for reference
  # Note: prev is already from nixpkgs, this is explicit
  nixpkgs = import inputs.nixpkgs nixpkgsConfig;

  # Patched nixpkgs (with patches from infra/patches.nix applied via applyPatches)
  # NOTE: infra/ subdirectory is intentional (Phase 1 architectural decision)
  patched = import (prev.applyPatches {
    name = "nixpkgs-patched";
    src = inputs.nixpkgs.outPath;
    patches = map prev.fetchpatch (import ./infra/patches.nix);
  }) nixpkgsConfig;

  # Stable channel (OS-specific: darwin-stable or linux-stable)
  # Uses lib'.systemInput to select appropriate input
  stable = import (lib'.systemInput {
    inherit os;
    name = "nixpkgs";
    channel = "stable";
  }) nixpkgsConfig;

  # Explicit unstable (for clarity when pulling from unstable)
  unstable = import inputs.nixpkgs nixpkgsConfig;
}
```

**Dendritic Adaptation Notes:**
- Remove `{ flake, ... }:` wrapper (replace with `inputs:` parameter)
- Pass inputs from nixpkgs.nix: `(import ./overlays/inputs.nix inputs)`
- Simplify patches array (test-clan has no patches, use empty array)
- Verify lib'.systemInput available (may need to import from test-clan lib)

### Layer 2: Platform Hotfixes (overlays/infra/hotfixes.nix - Complete Implementation)

```nix
# Platform-specific hotfixes for broken unstable packages
#
# Strategy: Selectively inherit from final.stable when unstable packages break
# This avoids flake.lock rollbacks that affect ALL packages
#
# Pattern:
# - Use final.stable.packageName for stable fallback
# - Document with hydra link: https://hydra.nixos.org/job/nixpkgs/trunk/PACKAGE.SYSTEM
# - Remove when upstream fixes land in unstable
#
# Prefer this over:
# - Flake.lock rollback (affects all packages)
# - Inline overrides in default.nix (clutters overlay)
#
final: prev:
{
  # Cross-platform hotfixes (all systems)
  inherit (final.stable)
    # https://hydra.nixos.org/job/nixpkgs/trunk/micromamba.aarch64-darwin
    # https://hydra.nixos.org/job/nixpkgs/trunk/micromamba.x86_64-linux
    # https://hydra.nixos.org/job/nixpkgs/trunk/micromamba.aarch64-linux
    # Error: fmt library compatibility issue across all platforms
    # - Formatter<fs::u8path> missing const qualifier on format method
    # - Darwin: clang 21.x exposes issue immediately
    # - Linux: Same underlying fmt library issue affects all platforms
    # - Breaks in unstable after 2025-09-28 (last successful hydra build)
    # - Stable version pulls compatible ghc_filesystem, solving both issues
    # - CI confirmed failure on Linux builds, not just Darwin
    # TODO: Remove when fmt compatibility fixed upstream
    # Added: 2025-10-13, expanded to all platforms: 2025-10-14
    micromamba
    ;
}
// (prev.lib.optionalAttrs prev.stdenv.isDarwin {
  # Darwin-wide hotfixes (both aarch64 and x86_64)
  # (Add Darwin-specific hotfixes here as needed)
})
// (prev.lib.optionalAttrs (prev.stdenv.hostPlatform.system == "x86_64-darwin") {
  # x86_64-darwin specific hotfixes
  # Example:
  # ncdu = final.empty or (prev.runCommand "empty-ncdu" {} "mkdir -p $out");
})
// (prev.lib.optionalAttrs (prev.stdenv.hostPlatform.system == "aarch64-darwin") {
  # aarch64-darwin specific hotfixes
  # (Add as needed)
})
// (prev.lib.optionalAttrs prev.stdenv.isLinux {
  # Linux-wide hotfixes
  # (Add as needed)
})
```

**Dendritic Adaptation Notes:**
- Pure overlay function (final: prev:) - NO changes needed
- Direct copy to test-clan/modules/flake-parts/overlays/hotfixes.nix
- Depends on Layer 1 (requires final.stable from inputs overlay)
- MUST be imported AFTER Layer 1 in nixpkgs.nix overlays array

### Layer 4: Package Overrides (overlays/overrides/default.nix - Infrastructure Code)

```nix
# Auto-import all package overrides
#
# This directory contains per-package build modifications:
# - overrideAttrs changes
# - Test disabling
# - Build flag modifications
# - Patch applications
#
# Each file should export an overlay: final: prev: { ... }
#
# See README.md for when to use overrides vs hotfixes vs patches
#
{ flake, ... }:
final: prev:
let
  inherit (flake.inputs.nixpkgs) lib;

  # Auto-import all *.nix files except default.nix and _*.nix
  filterPath =
    name: type:
    !lib.hasPrefix "_" name && type == "regular" && lib.hasSuffix ".nix" name && name != "default.nix";

  dirContents = builtins.readDir ./.;
  filteredContents = lib.filterAttrs filterPath dirContents;
  overlayFiles = builtins.attrNames filteredContents;

  # Import each overlay file and merge them
  importedOverlays = builtins.foldl' (
    acc: name:
    let
      overlay = import (./. + "/${name}") final prev;
    in
    acc // overlay
  ) { } overlayFiles;
in
importedOverlays
```

**Dendritic Adaptation Notes:**
- Remove `{ flake, ... }:` wrapper (no parameters needed for test-clan)
- Simplify to placeholder overlay (infra has infrastructure but no actual overrides)
- test-clan simplified version:
  ```nix
  # Per-package build modifications
  # Adapted from infra/overlays/overrides/default.nix
  final: prev:
  {
    # Package-specific overrideAttrs customizations
    # infra has auto-import infrastructure but no actual overrides yet
    # This is a placeholder for future package build modifications

    # Example override (if needed):
    # somePackage = prev.somePackage.overrideAttrs (oldAttrs: {
    #   doCheck = false;  # Disable tests
    # });
  }
  ```

### Layer 5: Flake Input Overlays (overlays/default.nix lines 44-65 - Pattern Example)

```nix
# Overlays from flake inputs
flakeInputs = {
  # Expose nuenv for nushell script packaging (analogous to writeShellApplication for bash)
  nuenv = (inputs.nuenv.overlays.nuenv self super).nuenv;

  # NOTE: jujutsu overlay disabled due to disk space constraints in CI
  # Building jujutsu from source (inputs.jj) causes "No space left on device" errors
  # Using nixpkgs version instead until CI runners have more disk space
  #
  # Original overlay (disabled):
  # jujutsu = inputs.jj.packages.${super.system}.jujutsu or super.jujutsu;
  #
  # To re-enable: uncomment above line and ensure sufficient disk space (~20GB+)
  # Reference: https://github.com/martinvonz/jj

  # nvim-treesitter override is now provided by LazyVim-module's overlay
  # See: inputs.lazyvim.overlays.nvim-treesitter-main applied in flake.nix
  # This approach is preferred as it:
  # - Uses LazyVim-module's flake inputs (automatically updated)
  # - Centralizes all LazyVim/neovim configuration in LazyVim-module
  # - Avoids duplicate overlay logic with hardcoded hashes
};
```

**Dendritic Adaptation Notes:**
- Extract flakeInputs from lib.mergeAttrsList composition
- Add directly to nixpkgs.nix overlays array
- test-clan integration:
  ```nix
  # In flake.nix inputs:
  inputs.nuenv.url = "github:DeterminateSystems/nuenv";

  # In modules/flake-parts/nixpkgs.nix overlays array:
  overlays = [
    # ... Layers 1, 2, 4
    inputs.nuenv.overlays.nuenv  # Layer 5: nuenv overlay
  ];
  ```

### Complete nixpkgs.nix Integration (Target Configuration)

```nix
# test-clan/modules/flake-parts/nixpkgs.nix
# Complete 5-layer overlay architecture integration
{ inputs, ... }:
{
  imports = [ inputs.pkgs-by-name-for-flake-parts.flakeModule ];

  perSystem = { system, ... }: {
    _module.args.pkgs = import inputs.nixpkgs {
      inherit system;
      config = { allowUnfree = true; };
      overlays = [
        # Layer 1: Multi-channel access
        # Provides: pkgs.stable.*, pkgs.unstable.*, pkgs.patched.*
        (import ./overlays/inputs.nix inputs)

        # Layer 2: Platform hotfixes
        # Provides: Stable fallbacks for broken unstable packages
        # Depends on: Layer 1 (needs final.stable)
        (import ./overlays/hotfixes.nix)

        # Layer 4: Package overrides
        # Provides: Per-package build modifications
        # Depends on: Layers 1-2 (can reference all prior layers)
        (import ./overlays/overrides.nix)

        # Layer 5: Flake input overlays
        # Provides: External overlay integration (nuenv, etc.)
        # Depends on: Layers 1-4 (external overlays reference everything)
        inputs.nuenv.overlays.nuenv
      ];
    };

    # Layer 3: Custom packages (Story 1.10D)
    # Provides: Custom derivations via pkgs-by-name auto-discovery
    # Standalone: No dependencies on other layers
    pkgsDirectory = ../pkgs/by-name;
  };
}
```

### Validation Command Examples with Expected Outputs

```bash
# Layer 1 validation (multi-channel access):
$ nix eval .#darwinConfigurations.blackphos.pkgs.stable.hello.version
"2.12.1"  # Stable version (example)

$ nix eval .#darwinConfigurations.blackphos.pkgs.unstable.hello.version
"2.13.0"  # Unstable version (example, newer than stable)

# Verify channels different (critical validation):
$ test "$(nix eval .#darwinConfigurations.blackphos.pkgs.stable.hello.version)" != \
       "$(nix eval .#darwinConfigurations.blackphos.pkgs.unstable.hello.version)" && \
       echo "✅ PASS: Channels provide different versions" || \
       echo "❌ FAIL: Channels identical"
✅ PASS: Channels provide different versions

# Layer 2 validation (hotfixes):
$ nix eval .#darwinConfigurations.blackphos.pkgs.micromamba.version
"1.5.10"  # Stable version (example)

$ nix eval .#darwinConfigurations.blackphos.pkgs.unstable.micromamba.version
"1.6.0"  # Unstable version (example, different from hotfix)

# Verify hotfix applied (micromamba uses stable):
$ test "$(nix eval .#darwinConfigurations.blackphos.pkgs.micromamba.version)" = \
       "$(nix eval .#darwinConfigurations.blackphos.pkgs.stable.micromamba.version)" && \
       echo "✅ PASS: Hotfix applied (uses stable)" || \
       echo "❌ FAIL: Hotfix not applied"
✅ PASS: Hotfix applied (uses stable)

# Layer 3 validation (pkgs-by-name from Story 1.10D):
$ nix build .#ccstatusline
# Expected: Build succeeds, no errors
$ ls -lh result/bin/ccstatusline
-r-xr-xr-x  1 user  staff   123K Nov 16 10:00 result/bin/ccstatusline

# Layer 5 validation (flake input overlays):
$ nix eval .#darwinConfigurations.blackphos.pkgs.nuenv.version
"0.3.1"  # nuenv version (example)

$ nix eval .#darwinConfigurations.blackphos.pkgs.nuenv.mkScript
{ type = "lambda"; }  # Function exists (nuenv main API)

# All configurations build validation:
$ nix build .#darwinConfigurations.blackphos.system
# Expected: Build succeeds
$ nix build .#nixosConfigurations.cinnabar.config.system.build.toplevel
# Expected: Build succeeds
$ nix build .#homeConfigurations.crs58.activationPackage
# Expected: Build succeeds
$ nix build .#homeConfigurations.raquel.activationPackage
# Expected: Build succeeds

# Zero regression validation (Story 1.10D):
$ nix build .#checks.aarch64-darwin.home-module-exports
# Expected: Build succeeds, no errors
$ nix build .#checks.aarch64-darwin.home-configurations-exposed
# Expected: Build succeeds, no errors
```

## Migration Sequence (Step-by-Step Guide)

### Phase 1: Directory Structure Setup (10 minutes)

```bash
# Navigate to test-clan repository
cd ~/projects/nix-workspace/test-clan

# Create overlay directory structure
mkdir -p modules/flake-parts/overlays

# Verify directory created
ls -ld modules/flake-parts/overlays
# Expected: drwxr-xr-x  ... modules/flake-parts/overlays/
```

### Phase 2: Layer 1 Migration (20 minutes)

```bash
# 1. Copy inputs.nix from infra
cp ~/projects/nix-workspace/infra/overlays/inputs.nix \
   ~/projects/nix-workspace/test-clan/modules/flake-parts/overlays/inputs.nix

# 2. Edit inputs.nix to adapt overlayArgs pattern
# Open in editor and:
# - Change line 15: `{ flake, ... }:` → `inputs:`
# - Change line 18: `inherit (flake) inputs;` → (remove this line, inputs already passed)
# - Change line 45: `patches = map prev.fetchpatch (import ./infra/patches.nix);` → `patches = [];`
# - Verify lib'.systemInput available (may need adaptation)

# 3. Import in nixpkgs.nix
# Edit modules/flake-parts/nixpkgs.nix
# Add to overlays array (line 19 after existing overlays):
#   (import ./overlays/inputs.nix inputs)

# 4. Validate
nix flake check  # Verify no evaluation errors
nix eval .#darwinConfigurations.blackphos.pkgs.stable.hello.version
nix eval .#darwinConfigurations.blackphos.pkgs.unstable.hello.version
# Expected: Different version numbers
```

### Phase 3: Layer 2 Migration (10 minutes)

```bash
# 1. Copy hotfixes.nix from infra (pure overlay, no changes needed)
cp ~/projects/nix-workspace/infra/overlays/infra/hotfixes.nix \
   ~/projects/nix-workspace/test-clan/modules/flake-parts/overlays/hotfixes.nix

# 2. Import in nixpkgs.nix (AFTER Layer 1)
# Edit modules/flake-parts/nixpkgs.nix
# Add to overlays array after Layer 1:
#   (import ./overlays/hotfixes.nix)

# 3. Validate
nix flake check  # Verify no evaluation errors
nix eval .#darwinConfigurations.blackphos.pkgs.micromamba.version
nix eval .#darwinConfigurations.blackphos.pkgs.stable.micromamba.version
# Expected: Same version (hotfix applied)
```

### Phase 4: Layer 4 Migration (10 minutes)

```bash
# 1. Create simplified overrides.nix (infra has infrastructure but no overrides)
cat > ~/projects/nix-workspace/test-clan/modules/flake-parts/overlays/overrides.nix <<'EOF'
# Per-package build modifications
# Adapted from infra/overlays/overrides/default.nix
final: prev:
{
  # Package-specific overrideAttrs customizations
  # infra has auto-import infrastructure but no actual overrides yet
  # This is a placeholder for future package build modifications

  # Example override (if needed):
  # somePackage = prev.somePackage.overrideAttrs (oldAttrs: {
  #   doCheck = false;  # Disable tests
  # });
}
EOF

# 2. Import in nixpkgs.nix (AFTER Layer 2)
# Edit modules/flake-parts/nixpkgs.nix
# Add to overlays array after Layer 2:
#   (import ./overlays/overrides.nix)

# 3. Validate
nix flake check  # Verify no evaluation errors
nix build .#darwinConfigurations.blackphos.system  # Verify builds
```

### Phase 5: Layer 5 Configuration (10 minutes)

```bash
# 1. Add nuenv flake input
# Edit flake.nix inputs section, add:
#   inputs.nuenv.url = "github:DeterminateSystems/nuenv";

# 2. Update flake.lock
nix flake lock  # Fetches nuenv dependency

# 3. Import nuenv overlay in nixpkgs.nix (AFTER Layer 4)
# Edit modules/flake-parts/nixpkgs.nix
# Add to overlays array after Layer 4:
#   inputs.nuenv.overlays.nuenv

# 4. Validate
nix flake check  # Verify no evaluation errors
nix eval .#darwinConfigurations.blackphos.pkgs.nuenv.version
# Expected: Version string (e.g., "0.3.1")
```

### Phase 6: Hybrid Pattern Validation (20 minutes)

```bash
# 1. Build all 4 configurations
nix build .#darwinConfigurations.blackphos.system
nix build .#nixosConfigurations.cinnabar.config.system.build.toplevel
nix build .#homeConfigurations.crs58.activationPackage
nix build .#homeConfigurations.raquel.activationPackage
# Expected: All builds succeed

# 2. Inspect merged pkgs (all 5 layers)
nix eval .#darwinConfigurations.blackphos.pkgs.stable.hello.version       # Layer 1
nix eval .#darwinConfigurations.blackphos.pkgs.micromamba.version        # Layer 2
nix build .#ccstatusline                                                 # Layer 3
nix eval .#darwinConfigurations.blackphos.pkgs.nuenv.version             # Layer 5
# Expected: All commands succeed, packages accessible

# 3. Zero regression validation (CRITICAL)
nix build .#ccstatusline  # Story 1.10D package still builds
nix build .#checks.aarch64-darwin.home-module-exports  # Story 1.10D check 1
nix build .#checks.aarch64-darwin.home-configurations-exposed  # Story 1.10D check 2
# Expected: All builds succeed (zero failures tolerated)
```

### Phase 7: Documentation (30 minutes)

```bash
# 1. Create Section 13.2 structure
# Edit ~/projects/nix-workspace/test-clan/docs/architecture/test-clan-validated-architecture.md
# Add after Section 13.1:
# ## 13.2 Overlay Architecture Preservation with Dendritic Pattern

# 2. Document all 5 layers with empirical evidence
# - Layer 1: Full inputs.nix code + validation commands
# - Layer 2: Full hotfixes.nix code + micromamba example
# - Layer 3: Reference Section 13.1 (Story 1.10D)
# - Layer 4: overrides.nix infrastructure + pattern explanation
# - Layer 5: nuenv overlay integration example
# - Integration: Complete nixpkgs.nix with all layers
# - Build validation: All commands with expected outputs
# - Migration guide: 8-step procedure with effort estimates

# 3. Verify quality matches Section 13.1
# - Empirical examples (real code, not hypothetical)
# - Build validation commands with actual outputs
# - Comprehensive tutorial (Epic 2-6 can execute migration)
# - 9.5/10 clarity target (Story 1.10D baseline)
```

## Troubleshooting Guide

### Problem: Layer 1 inputs.nix evaluation error "lib' undefined"

**Symptom:** `error: attribute 'systemOs' missing`

**Cause:** lib'.systemOs not available in test-clan (infra-specific lib function)

**Solution:** Adapt systemInput usage or import from test-clan lib
```nix
# Option 1: Direct stable input reference (simpler for test-clan)
stable = import inputs.nixpkgs-darwin-stable nixpkgsConfig;  # For darwin
# OR
stable = import inputs.nixpkgs-linux-stable nixpkgsConfig;   # For linux

# Option 2: Conditional based on system (if multi-platform)
stable = if prev.stdenv.isDarwin
         then import inputs.nixpkgs-darwin-stable nixpkgsConfig
         else import inputs.nixpkgs-linux-stable nixpkgsConfig;
```

### Problem: Layer 2 hotfixes.nix "final.stable undefined"

**Symptom:** `error: attribute 'stable' missing in 'final'`

**Cause:** Layer 2 imported BEFORE Layer 1 in overlays array

**Solution:** Verify overlays array ordering in nixpkgs.nix
```nix
overlays = [
  (import ./overlays/inputs.nix inputs)  # Layer 1 MUST be first
  (import ./overlays/hotfixes.nix)       # Layer 2 uses final.stable from Layer 1
  # ...
];
```

### Problem: nuenv overlay not accessible

**Symptom:** `error: attribute 'nuenv' missing in 'pkgs'`

**Cause:** nuenv flake input not added to flake.nix OR overlay not imported

**Solution:** Verify both flake input AND overlay import
```nix
# In flake.nix inputs:
inputs.nuenv.url = "github:DeterminateSystems/nuenv";  # Check this exists

# In nixpkgs.nix overlays array:
inputs.nuenv.overlays.nuenv  # Check this is imported (Layer 5, last overlay)
```

### Problem: Story 1.10D regression (ccstatusline build fails)

**Symptom:** `error: builder for '/nix/store/...-ccstatusline-...' failed`

**Cause:** Overlay changes broke pkgs-by-name infrastructure

**Solution:** Verify pkgsDirectory still configured in nixpkgs.nix
```nix
perSystem = { system, ... }: {
  _module.args.pkgs = import inputs.nixpkgs {
    # ... overlays array
  };
  pkgsDirectory = ../pkgs/by-name;  # CRITICAL: Must be present
};
```

### Problem: All builds failing with "infinite recursion"

**Symptom:** `error: infinite recursion encountered`

**Cause:** Overlay layer dependency cycle (Layer N depends on Layer N+1)

**Solution:** Review overlays array ordering, ensure dependencies flow forward only
```nix
# CORRECT order (dependencies flow forward):
overlays = [
  Layer1  # Provides: stable, unstable (no dependencies)
  Layer2  # Uses: final.stable from Layer1
  Layer4  # Uses: Layers 1-2 packages
  Layer5  # Uses: All prior layers
];

# INCORRECT order (creates dependency cycle):
overlays = [
  Layer2  # ❌ FAIL: Tries to use final.stable before Layer1 defines it
  Layer1  # Defined too late
];
```
  </codeExamples>
</story-context>
