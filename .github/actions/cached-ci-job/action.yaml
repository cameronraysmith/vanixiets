name: Cached CI Job
description: Execute job only if not already successful for this commit SHA

inputs:
  check-name:
    description: Full check run name (defaults to github.job, include matrix values for matrix jobs)
    required: false
    default: ${{ github.job }}
  path-filters:
    description: Regex pattern for relevant file paths (empty means always relevant)
    required: false
    default: ''
  force-run:
    description: Force execution even if already successful
    required: false
    default: 'false'

outputs:
  should-run:
    description: Whether job should execute (true/false)
    value: ${{ steps.decide.outputs.should-run }}
  previously-succeeded:
    description: Whether this job previously succeeded for this commit
    value: ${{ steps.check-history.outputs.previously-succeeded }}
  relevant-changes:
    description: Whether relevant file changes were detected
    value: ${{ steps.check-paths.outputs.relevant-changes }}
  changed-files:
    description: List of changed files matching path filters (when path-filters specified)
    value: ${{ steps.changed-files.outputs.all_changed_files || '' }}
  any-changed:
    description: Whether any files matching path filters changed (when path-filters specified)
    value: ${{ steps.changed-files.outputs.any_changed || 'false' }}
  all-changed-files:
    description: List of all changed files (for debugging workflow change detection)
    value: ${{ steps.all-changed-files.outputs.all_changed_files || '' }}
  content-hash:
    description: Job-specific content hash for debugging and analysis
    value: ${{ steps.content-hash.outputs.content-hash || '' }}

runs:
  using: composite
  steps:
    - name: Query GitHub Checks API for execution history
      id: check-history
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # ratchet:actions/github-script@v7
      env:
        CHECK_NAME: ${{ inputs.check-name }}
      with:
        script: |
          const checkName = process.env.CHECK_NAME;
          const commit = context.sha;

          core.info(`Querying execution history for: "${checkName}" @ ${commit}`);

          try {
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: commit,
              check_name: checkName,
            });

            core.info(`Found ${checks.check_runs.length} check run(s) for this commit`);

            // Find any completed successful run
            const successfulRun = checks.check_runs.find(run =>
              run.conclusion === 'success' &&
              run.status === 'completed'
            );

            if (successfulRun) {
              core.info(`✓ Job already succeeded: ${successfulRun.html_url}`);
              core.setOutput('previously-succeeded', 'true');
            } else {
              const failedRuns = checks.check_runs.filter(run =>
                run.conclusion === 'failure' &&
                run.status === 'completed'
              );
              if (failedRuns.length > 0) {
                core.info(`✗ Found ${failedRuns.length} previous failed run(s)`);
              } else {
                core.info(`✗ No previous runs found`);
              }
              core.setOutput('previously-succeeded', 'false');
            }
          } catch (error) {
            core.warning(`API query failed: ${error.message}`);
            core.setOutput('previously-succeeded', 'false');
          }

    
    - name: Get ALL changed files (for workflow detection)
      id: all-changed-files
      if: steps.check-history.outputs.previously-succeeded != 'true'
      uses: tj-actions/changed-files@24d32ffd492484c1d75e0c0b894501ddb9d30d62
      with:
        json: true
        separator: ','

    - name: Get filtered changed files (for path filtering)
      id: changed-files
      if: |
        steps.check-history.outputs.previously-succeeded != 'true' &&
        inputs.path-filters != ''
      uses: tj-actions/changed-files@24d32ffd492484c1d75e0c0b894501ddb9d30d62
      with:
        files: ${{ inputs.path-filters }}
        json: true
        separator: ','

    - name: Compute job-specific content hash
      id: content-hash
      if: steps.check-history.outputs.previously-succeeded != 'true'
      shell: bash
      env:
        CHECK_NAME: ${{ inputs.check-name }}
        PATH_FILTERS: ${{ inputs.path-filters }}
      run: |
        echo "=== Computing Content Hash ==="

        # Base content hash from commit SHA
        CONTENT_HASH="${{ github.sha }}"
        echo "Base hash (commit SHA): $CONTENT_HASH"

        # Add workflow file hash to detect job definition changes
        WF_HASH=$(git hash-object .github/workflows/ci.yaml 2>/dev/null || echo "unknown")
        CONTENT_HASH="${CONTENT_HASH}-${WF_HASH}"
        echo "Workflow hash: $WF_HASH"

        # Add composite action hash to detect logic changes
        ACTION_HASH=$(git hash-object .github/actions/cached-ci-job/action.yaml 2>/dev/null || echo "unknown")
        CONTENT_HASH="${CONTENT_HASH}-${ACTION_HASH}"
        echo "Action hash: $ACTION_HASH"

        # Add relevant file content hashing when path filters are specified
        if [ -n "$PATH_FILTERS" ]; then
          echo "Path filters active: $PATH_FILTERS"

          # Use filtered changed files from previous step if available
          if [ -n "${{ steps.changed-files.outputs.all_changed_files || '' }}" ]; then
            CHANGED_FILES="${{ steps.changed-files.outputs.all_changed_files }}"
            echo "Using filtered changed files: $CHANGED_FILES"

            # Hash each changed file
            FILE_HASHES=""
            for file in $(echo "$CHANGED_FILES" | tr ',' '\n'); do
              if [ -f "$file" ]; then
                FILE_HASH=$(git hash-object "$file" 2>/dev/null)
                if [ -n "$FILE_HASH" ]; then
                  FILE_HASHES="${FILE_HASHES}${FILE_HASH}"
                fi
              fi
            done

            # Create final file hash
            if [ -n "$FILE_HASHES" ]; then
              RELEVANT_HASH=$(echo "$FILE_HASHES" | sha256sum | cut -d' ' -f1)
              CONTENT_HASH="${CONTENT_HASH}-${RELEVANT_HASH}"
              echo "Relevant files hash: $RELEVANT_HASH"
            fi
          else
            echo "No changed files available for hashing"
          fi
        else
          echo "No path filters - skipping file content hashing"
        fi

        echo "Final content hash: $CONTENT_HASH"
        echo "content-hash=$CONTENT_HASH" >> $GITHUB_OUTPUT

    - name: Check for relevant file changes
      id: check-paths
      if: |
        steps.check-history.outputs.previously-succeeded != 'true'
      shell: bash
      env:
        HAS_FILTERS: ${{ inputs.path-filters != '' }}
        ALL_CHANGED_FILES: ${{ steps.all-changed-files.outputs.all_changed_files || '' }}
        FILTERED_CHANGED: ${{ steps.changed-files.outputs.any_changed || 'false' }}
        FILTERED_FILES: ${{ steps.changed-files.outputs.all_changed_files || '' }}
      run: |
        echo "=== File Change Analysis ==="
        echo "Has path filters: $HAS_FILTERS"
        echo "All changed files: $ALL_CHANGED_FILES"
        echo "Filtered changed: $FILTERED_CHANGED"
        echo "Filtered files: $FILTERED_FILES"
        echo ""

        # Check for workflow changes FIRST (using all changed files)
        if echo "$ALL_CHANGED_FILES" | grep -q '\.github/workflows/'; then
          echo "✓ Workflow changes detected - job is always relevant"
          echo "relevant-changes=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        if [ "$HAS_FILTERS" = "true" ]; then
          # Path filtering is enabled and no workflow changes
          if [ "$FILTERED_CHANGED" = "true" ]; then
            echo "✓ Relevant file changes detected"
            echo "Changed files: $FILTERED_FILES"
            echo "relevant-changes=true" >> $GITHUB_OUTPUT
          else
            echo "✗ No relevant file changes detected"
            echo "relevant-changes=false" >> $GITHUB_OUTPUT
          fi
        else
          # No path filters - always relevant if no workflow changes
          echo "✓ No path filters specified - job is always relevant"
          echo "relevant-changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Make execution decision
      id: decide
      shell: bash
      env:
        FORCE: ${{ inputs.force-run }}
        PREV_SUCCESS: ${{ steps.check-history.outputs.previously-succeeded }}
        HAS_CHANGES: ${{ steps.check-paths.outputs.relevant-changes }}
        HAS_FILTERS: ${{ inputs.path-filters != '' }}
      run: |
        echo "=== Execution Decision ==="
        echo "Force run: $FORCE"
        echo "Previously succeeded: $PREV_SUCCESS"
        echo "Has path filters: $HAS_FILTERS"
        echo "Relevant changes: $HAS_CHANGES"
        echo ""

        # Force run overrides everything
        if [ "$FORCE" = "true" ]; then
          echo "should-run=true" >> $GITHUB_OUTPUT
          echo "Decision: RUN (forced by input)"
          exit 0
        fi

        # If already succeeded for this commit, skip
        if [ "$PREV_SUCCESS" = "true" ]; then
          echo "should-run=false" >> $GITHUB_OUTPUT
          echo "Decision: SKIP (already succeeded for this commit)"
          exit 0
        fi

        # If we have path filters, honor them
        if [ "$HAS_FILTERS" = "true" ]; then
          echo "should-run=${HAS_CHANGES}" >> $GITHUB_OUTPUT
          if [ "$HAS_CHANGES" = "true" ]; then
            echo "Decision: RUN (relevant file changes detected)"
          else
            echo "Decision: SKIP (no relevant file changes)"
          fi
        else
          # No filters means always run if not already succeeded
          echo "should-run=true" >> $GITHUB_OUTPUT
          echo "Decision: RUN (no path filters specified)"
        fi
