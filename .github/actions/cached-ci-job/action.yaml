name: Cached CI Job
description: Execute job only if not already successful for this commit SHA

inputs:
  check-name:
    description: Full check run name (defaults to github.job, include matrix values for matrix jobs)
    required: false
    default: ${{ github.job }}
  hash-sources:
    description: |
      Glob patterns for files to hash (one per line or space-separated).
      Used to compute content-addressed cache key.
      Example: '**/*.nix flake.lock Makefile'
      The workflow file is automatically included.
    required: false
    default: ''
  force-run:
    description: Force execution even if already successful
    required: false
    default: 'false'

outputs:
  should-run:
    description: Whether job should execute (true/false)
    value: ${{ steps.decide.outputs.should-run }}
  cache-source:
    description: 'Where cache hit occurred (actions-cache or none)'
    value: ${{ steps.decide.outputs.cache-source }}
  cache-key:
    description: 'Content-addressed cache key'
    value: ${{ steps.compute-hash.outputs.cache-key }}
  cache-path:
    description: 'Cache directory path for job result marker'
    value: ${{ steps.compute-hash.outputs.cache-path }}

runs:
  using: composite
  steps:
    - name: Compute content-addressed cache key
      id: compute-hash
      shell: bash
      env:
        CHECK_NAME: ${{ inputs.check-name }}
        HASH_SOURCES: ${{ inputs.hash-sources }}
      run: |
        echo "::notice title=Cache Key Computation::Computing content-addressed cache key for $CHECK_NAME"

        # Sanitize check name
        SANITIZED=$(echo "$CHECK_NAME" | tr -d '()' | tr ', ' '-' | tr -s '-')

        # Get workflow file path (automatically included in hash)
        WORKFLOW_FILE=$(echo "$GITHUB_WORKFLOW_REF" | sed 's|^[^/]*/[^/]*/||' | sed 's|@.*||')
        echo "Workflow file: $WORKFLOW_FILE"

        # Combine user sources + workflow file
        if [ -n "$HASH_SOURCES" ]; then
          ALL_SOURCES="$HASH_SOURCES $WORKFLOW_FILE"
        else
          # If no sources specified, use workflow file only
          ALL_SOURCES="$WORKFLOW_FILE"
        fi

        echo "Hash sources: $ALL_SOURCES"

        # Compute content hash of all source files
        # Note: Using git hash-object for consistency with Git's object hashing
        CONTENT_HASH=""
        for pattern in $ALL_SOURCES; do
          # Find matching files and compute their hashes
          if [ -f "$pattern" ]; then
            # Single file
            FILE_HASH=$(git hash-object "$pattern" 2>/dev/null || echo "missing")
            CONTENT_HASH="${CONTENT_HASH}${FILE_HASH}"
          else
            # Glob pattern - expand and hash each file
            for file in $pattern; do
              if [ -f "$file" ]; then
                FILE_HASH=$(git hash-object "$file" 2>/dev/null || echo "missing")
                CONTENT_HASH="${CONTENT_HASH}${FILE_HASH}"
              fi
            done
          fi
        done

        # Hash the concatenated hashes to get final content hash
        FINAL_HASH=$(echo -n "$CONTENT_HASH" | sha256sum | cut -c1-12)

        # Construct cache key
        CACHE_KEY="job-result-${SANITIZED}-${FINAL_HASH}"
        CACHE_PATH=".cache/job-results/${SANITIZED}"

        echo "Content hash: $FINAL_HASH"
        echo "Cache key: $CACHE_KEY"
        echo "Cache path: $CACHE_PATH"

        # Use GitHub Actions notice annotation for visibility
        echo "::notice title=Cache Key (${CHECK_NAME})::${CACHE_KEY}"

        echo "cache-key=$CACHE_KEY" >> $GITHUB_OUTPUT
        echo "cache-path=$CACHE_PATH" >> $GITHUB_OUTPUT
        echo "content-hash=$FINAL_HASH" >> $GITHUB_OUTPUT

    - name: Prepare cache restore keys
      id: cache-result
      shell: bash
      env:
        CHECK_NAME: ${{ inputs.check-name }}
      run: |
        # Sanitize check name for restore-keys
        SANITIZED=$(echo "$CHECK_NAME" | tr -d '()' | tr ', ' '-' | tr -s '-')
        RESTORE_KEYS="job-result-${SANITIZED}-"

        echo "Restore keys pattern: ${RESTORE_KEYS}*"
        echo "restore-keys=$RESTORE_KEYS" >> $GITHUB_OUTPUT

    - name: Lookup job result in actions/cache
      id: cache-lookup
      uses: actions/cache/restore@0057852bfaa89a56745cba8c7296529d2fc39830 # ratchet:actions/cache/restore@v4
      with:
        path: ${{ steps.compute-hash.outputs.cache-path }}
        key: ${{ steps.compute-hash.outputs.cache-key }}
        restore-keys: ${{ steps.cache-result.outputs.restore-keys }}
        lookup-only: true

    - name: Make execution decision
      id: decide
      shell: bash
      env:
        FORCE: ${{ inputs.force-run }}
        CACHE_HIT: ${{ steps.cache-lookup.outputs.cache-hit || 'false' }}
        CACHE_KEY: ${{ steps.compute-hash.outputs.cache-key }}
        CHECK_NAME: ${{ inputs.check-name }}
      run: |
        echo "=== Execution Decision ==="
        echo "Force run: $FORCE"
        echo "Cache key: $CACHE_KEY"
        echo "Actions cache hit: $CACHE_HIT"
        echo ""

        # Force run overrides everything
        if [ "$FORCE" = "true" ]; then
          echo "should-run=true" >> $GITHUB_OUTPUT
          echo "cache-source=none" >> $GITHUB_OUTPUT
          echo "::notice title=Decision (${CHECK_NAME})::RUN (forced by input)"
          echo "Decision: RUN (forced by input)"
          exit 0
        fi

        # Check actions/cache (content-addressed)
        if [ "$CACHE_HIT" = "true" ]; then
          echo "should-run=false" >> $GITHUB_OUTPUT
          echo "cache-source=actions-cache" >> $GITHUB_OUTPUT
          echo "::notice title=Decision (${CHECK_NAME})::SKIP (cached result found for content hash)"
          echo "Decision: SKIP (cached result found)"
          exit 0
        fi

        # No cache hit - must run
        echo "should-run=true" >> $GITHUB_OUTPUT
        echo "cache-source=none" >> $GITHUB_OUTPUT
        echo "::notice title=Decision (${CHECK_NAME})::RUN (no cached result found)"
        echo "Decision: RUN (no cached result found)"
