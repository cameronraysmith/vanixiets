name: Cached CI Job
description: Execute job only if not already successful for this commit SHA

inputs:
  check-name:
    description: Full check run name (defaults to github.job, include matrix values for matrix jobs)
    required: false
    default: ${{ github.job }}
  path-filters:
    description: Regex pattern for relevant file paths (empty means always relevant)
    required: false
    default: ''
  workflow-file:
    description: 'Workflow file path (auto-detected if not provided)'
    required: false
    default: ''
  force-run:
    description: Force execution even if already successful
    required: false
    default: 'false'

outputs:
  should-run:
    description: Whether job should execute (true/false)
    value: ${{ steps.decide.outputs.should-run }}
  relevant-changes:
    description: Whether relevant file changes were detected
    value: ${{ steps.check-paths.outputs.relevant-changes }}
  changed-files:
    description: List of changed files matching path filters (when path-filters specified)
    value: ${{ steps.changed-files.outputs.all_changed_files || '' }}
  any-changed:
    description: Whether any files matching path filters changed (when path-filters specified)
    value: ${{ steps.changed-files.outputs.any_changed || 'false' }}
  all-changed-files:
    description: List of all changed files (for debugging workflow change detection)
    value: ${{ steps.changed-files.outputs.all_modified_files || '' }}
  content-hash:
    description: Job-specific content hash for debugging and analysis
    value: ${{ steps.content-hash.outputs.content-hash || '' }}
  cache-source:
    description: 'Where cache hit occurred (actions-cache or none)'
    value: ${{ steps.decide.outputs.cache-source }}
  cache-key:
    description: 'Sanitized cache key for actions/cache (no special characters)'
    value: ${{ steps.cache-result.outputs.cache-key }}
  cache-path:
    description: 'Cache directory path for job result marker'
    value: ${{ steps.cache-result.outputs.cache-path }}
  cache-restore-keys:
    description: 'Restore keys pattern for actions/cache fallback matching'
    value: ${{ steps.cache-result.outputs.cache-restore-keys }}

runs:
  using: composite
  steps:
    - name: Prepare cache key for actions/cache
      id: cache-result
      shell: bash
      env:
        CHECK_NAME: ${{ inputs.check-name }}
      run: |
        echo "=== Cache Key Preparation ==="

        # Sanitize check name: remove parens, convert ", " to "-", collapse multiple dashes
        SANITIZED=$(echo "$CHECK_NAME" | tr -d '()' | tr ', ' '-' | tr -s '-')

        # Use short SHA for uniqueness (prevents save collisions)
        SHA_SHORT="${GITHUB_SHA:0:12}"

        # Construct cache key and path
        CACHE_KEY="job-result-${SANITIZED}-${SHA_SHORT}"
        CACHE_PATH=".cache/job-results/${SANITIZED}"
        RESTORE_KEYS="job-result-${SANITIZED}-"

        echo "Check name: $CHECK_NAME"
        echo "Sanitized: $SANITIZED"
        echo "SHA prefix: $SHA_SHORT"
        echo "Cache key: $CACHE_KEY"
        echo "Cache path: $CACHE_PATH"
        echo "Restore pattern: ${RESTORE_KEYS}*"

        echo "cache-key=$CACHE_KEY" >> $GITHUB_OUTPUT
        echo "cache-path=$CACHE_PATH" >> $GITHUB_OUTPUT
        echo "cache-restore-keys=$RESTORE_KEYS" >> $GITHUB_OUTPUT

    - name: Lookup job result in actions/cache
      id: cache-lookup
      uses: actions/cache/restore@0057852bfaa89a56745cba8c7296529d2fc39830 # ratchet:actions/cache/restore@v4
      with:
        path: ${{ steps.cache-result.outputs.cache-path }}
        key: ${{ steps.cache-result.outputs.cache-key }}
        restore-keys: ${{ steps.cache-result.outputs.cache-restore-keys }}
        lookup-only: true

    - name: Get changed files (all + filtered)
      id: changed-files
      if: steps.cache-lookup.outputs.cache-hit != 'true'
      uses: tj-actions/changed-files@24d32ffd492484c1d75e0c0b894501ddb9d30d62
      with:
        # Use files_yaml for multiple pattern groups
        files_yaml: |
          all:
            - '**/*'
          filtered:
            - ${{ inputs.path-filters }}
        json: true
        separator: ','

    - name: Compute job-specific content hash (legacy)
      id: content-hash
      if: steps.cache-lookup.outputs.cache-hit != 'true'
      shell: bash
      run: |
        # Legacy output for backward compatibility
        echo "content-hash=${{ github.sha }}" >> $GITHUB_OUTPUT

    - name: Check for relevant file changes
      id: check-paths
      if: steps.cache-lookup.outputs.cache-hit != 'true'
      shell: bash
      env:
        HAS_FILTERS: ${{ inputs.path-filters != '' }}
        ALL_CHANGED_FILES: ${{ steps.changed-files.outputs.all_modified_files || '' }}
        FILTERED_CHANGED: ${{ steps.changed-files.outputs.filtered_any_changed || 'false' }}
        FILTERED_FILES: ${{ steps.changed-files.outputs.filtered_all_changed_files || '' }}
      run: |
        echo "=== File Change Analysis ==="
        echo "Has path filters: $HAS_FILTERS"
        echo "All changed files: $ALL_CHANGED_FILES"
        echo "Filtered changed: $FILTERED_CHANGED"
        echo "Filtered files: $FILTERED_FILES"
        echo ""

        # Check for workflow changes FIRST (current workflow only)
        WORKFLOW_PATH=$(echo "$GITHUB_WORKFLOW_REF" | sed 's|.*@refs/[^:]*:||')
        if echo "$ALL_CHANGED_FILES" | grep -qF "$WORKFLOW_PATH"; then
          echo "✓ Current workflow changed - job is always relevant"
          echo "relevant-changes=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        if [ "$HAS_FILTERS" = "true" ]; then
          # Path filtering is enabled and no workflow changes
          if [ "$FILTERED_CHANGED" = "true" ]; then
            echo "✓ Relevant file changes detected"
            echo "Changed files: $FILTERED_FILES"
            echo "relevant-changes=true" >> $GITHUB_OUTPUT
          else
            echo "✗ No relevant file changes detected"
            echo "relevant-changes=false" >> $GITHUB_OUTPUT
          fi
        else
          # No path filters - always relevant if no workflow changes
          echo "✓ No path filters specified - job is always relevant"
          echo "relevant-changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Make execution decision
      id: decide
      shell: bash
      env:
        FORCE: ${{ inputs.force-run }}
        CACHE_HIT: ${{ steps.cache-lookup.outputs.cache-hit || 'false' }}
        HAS_CHANGES: ${{ steps.check-paths.outputs.relevant-changes }}
        HAS_FILTERS: ${{ inputs.path-filters != '' }}
      run: |
        echo "=== Execution Decision ==="
        echo "Force run: $FORCE"
        echo "Actions cache hit: $CACHE_HIT"
        echo "Has path filters: $HAS_FILTERS"
        echo "Relevant changes: $HAS_CHANGES"
        echo ""

        # Force run overrides everything
        if [ "$FORCE" = "true" ]; then
          echo "should-run=true" >> $GITHUB_OUTPUT
          echo "cache-source=none" >> $GITHUB_OUTPUT
          echo "Decision: RUN (forced by input)"
          exit 0
        fi

        # Check actions/cache (cross-commit caching)
        if [ "$CACHE_HIT" = "true" ]; then
          echo "should-run=false" >> $GITHUB_OUTPUT
          echo "cache-source=actions-cache" >> $GITHUB_OUTPUT
          echo "Decision: SKIP (cached result found)"
          exit 0
        fi

        # If we have path filters, honor them
        if [ "$HAS_FILTERS" = "true" ]; then
          echo "should-run=${HAS_CHANGES}" >> $GITHUB_OUTPUT
          echo "cache-source=none" >> $GITHUB_OUTPUT
          if [ "$HAS_CHANGES" = "true" ]; then
            echo "Decision: RUN (relevant file changes detected)"
          else
            echo "Decision: SKIP (no relevant file changes)"
          fi
        else
          # No filters means always run if not already cached
          echo "should-run=true" >> $GITHUB_OUTPUT
          echo "cache-source=none" >> $GITHUB_OUTPUT
          echo "Decision: RUN (no path filters specified)"
        fi
